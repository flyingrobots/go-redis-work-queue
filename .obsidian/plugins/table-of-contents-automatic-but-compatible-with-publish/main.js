/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoTOC
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/globalData/globalData.ts
var tableStart = "<!-- Table of Contents ";
var endComment = "-->";
var endTable = "<!-- End of TOC -->";
var tocTitle = "# Table of Contents\n";

// src/markdownFunctions/arrowType.ts
function arrowType(tocHeading) {
  let styleText = tocHeading.slice(tableStart.length, -endTable.length).trim();
  let arrowType2;
  switch (styleText) {
    case "":
      arrowType2 = "default";
      break;
    default:
      arrowType2 = "default";
  }
  return arrowType2;
}

// src/markdownFunctions/createSubheading.ts
function createSubheading(fileName, tabLength, content) {
  if (content == void 0) {
    return "";
  }
  let subheadingContent = "";
  const heading = "#".repeat(tabLength) + " ";
  const tabIndent = "	".repeat(tabLength - 1);
  const splitText = "\n" + heading;
  const contentStartsWithHeading = content.trim()[0] == "#";
  let headings = content.trim().split(splitText).filter((t) => t.trim() != "");
  if (!contentStartsWithHeading) {
    headings = headings.slice(1);
  }
  let headingNum = 1;
  headings.forEach((section) => {
    const lineCheck = section.indexOf("\n");
    const lineSplit = lineCheck == -1 ? section.length : lineCheck;
    let headingTitle = section.slice(0, lineSplit);
    if (headingTitle.slice(0, heading.length) == heading) {
      headingTitle = headingTitle.slice(heading.length);
    }
    subheadingContent += `${tabIndent}${headingNum}. [[${fileName}${heading}${headingTitle}|${headingTitle}]]
`;
    headingNum += 1;
    const subheading = heading.replace(" ", "#");
    const subheadingLocation = section.indexOf(subheading);
    if (subheadingLocation != -1) {
      subheadingContent += createSubheading(
        fileName,
        tabLength + 1,
        section.slice(subheadingLocation)
      );
    }
  });
  return subheadingContent;
}

// src/markdownFunctions/contentToToc.ts
function contentToTOC(fileName, content, arrowType2 = "") {
  let table_of_contents = tableStart + endComment + "\n" + tocTitle;
  const tabCheck = content.indexOf("# ");
  if (tabCheck != -1) {
    table_of_contents += createSubheading(fileName, 1, content) + "\n";
  }
  table_of_contents += endTable + "\n";
  return table_of_contents;
}

// src/markdownFunctions/splitMarkdownUp.ts
function splitMarkdownUp(file) {
  const frontMatterCheckLine = "---";
  const tocStart = file.indexOf(tableStart);
  if (file.slice(0, 3) != frontMatterCheckLine) {
    if (tocStart == -1) {
      return ["", "", "", file];
    }
    const tocEnd2 = file.indexOf(endTable) + endTable.length;
    return [
      "",
      file.slice(0, tocStart),
      file.slice(tocStart, tocEnd2),
      file.slice(tocEnd2)
    ];
  }
  const frontMatterEndString = "\n---\n";
  const endFrontMatter = file.indexOf(frontMatterEndString);
  if (endFrontMatter == -1) {
    if (tocStart == -1) {
      return ["", "", "", file];
    }
    const tocEnd2 = file.indexOf(endTable) + endTable.length;
    return [
      "",
      file.slice(0, tocStart),
      file.slice(tocStart, tocEnd2),
      file.slice(tocEnd2)
    ];
  }
  if (tocStart == -1) {
    const splitIndex2 = endFrontMatter + frontMatterEndString.length;
    return [file.slice(0, splitIndex2), "", "", file.slice(splitIndex2)];
  }
  const tocEnd = file.indexOf(endTable) + endTable.length;
  const splitIndex = endFrontMatter + frontMatterEndString.length;
  return [
    file.slice(0, splitIndex),
    file.slice(splitIndex, tocStart),
    file.slice(tocStart, tocEnd),
    file.slice(tocEnd)
  ];
}

// src/markdownFunctions/createToc.ts
function createToc(fileContent, fileName) {
  const fileSplit = splitMarkdownUp(fileContent);
  const frontmatter = fileSplit[0];
  const preTOC = fileSplit[1];
  let arrowTypeTOC = arrowType(fileSplit[2]);
  const postTOC = fileSplit[3];
  const content = preTOC + postTOC;
  const toc = contentToTOC(fileName, content, arrowTypeTOC);
  const result = frontmatter + preTOC + toc + "\n" + postTOC.trim();
  return result;
}

// src/markdownFunctions/checkTOC.ts
async function checkToc(file) {
  const fileContent = await this.app.vault.read(file);
  const tocStart = fileContent.indexOf(tableStart);
  if (tocStart == -1) {
    return false;
  }
  const tocEnd = fileContent.indexOf(endTable);
  if (tocEnd > tocStart) {
    return true;
  }
  return false;
}

// src/markdownFunctions/oldToc.ts
function oldToc(fileContent) {
  const fileSplit = splitMarkdownUp(fileContent);
  return fileSplit[2];
}

// src/markdownFunctions/shouldUpdateToc.ts
async function shouldUpdateToc(file) {
  const fileName = file.basename;
  const fileSplit = splitMarkdownUp(await this.app.vault.read(file));
  let arrowTypeTOC = arrowType(fileSplit[2]);
  const content = fileSplit[1] + fileSplit[3];
  const toc = contentToTOC(fileName, content, arrowTypeTOC).trim();
  const oldTocMD = oldToc(await this.app.vault.cachedRead(file)).trim();
  const updateToc = !(toc === oldTocMD);
  return [updateToc, toc];
}

// src/markdownFunctions/updateFileToc.ts
function updateFileToc(fileContent, toc) {
  const tableStartIndex = fileContent.indexOf(tableStart);
  const tableEndIndex = fileContent.indexOf(endTable) + endTable.length;
  return fileContent.slice(0, tableStartIndex) + toc + fileContent.slice(tableEndIndex);
}

// src/main.ts
var AutoTOC = class extends import_obsidian.Plugin {
  async onload() {
    this.addCommand({
      id: "create-table-of-contents",
      name: "Create table of contents",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const fileName = file.basename;
          this.app.vault.process(file, (fileContent) => {
            return createToc(fileContent, fileName);
          });
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          return;
        }
        const checkTOC = await checkToc(file);
        if (!checkTOC) {
          return;
        }
        const [updateToc, toc] = await shouldUpdateToc(file);
        if (!updateToc) {
          return;
        }
        const Re = new RegExp(tableStart + ".*" + endTable);
        this.app.vault.process(file, (fileContent) => {
          return updateFileToc(fileContent, toc);
        });
        return;
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          return;
        }
        const checkTOC = await checkToc(file);
        if (!checkTOC) {
          return;
        }
        const [updateToc, toc] = await shouldUpdateToc(file);
        if (!updateToc) {
          return;
        }
        this.app.vault.process(file, (fileContent) => {
          return updateFileToc(fileContent, toc);
        });
        return;
      })
    );
  }
};


/* nosourcemap */