{
  "version": "3.0",
  "metadata": {
    "generated_at": "2025-09-14T16:49:01.338633Z",
    "total_tasks": 88,
    "total_dependencies": 60,
    "execution_model": "rolling_frontier",
    "estimated_duration_hours": 244.0
  },
  "graph": {
    "nodes": [
      {
        "id": "P1.T001",
        "name": "Design Admin Api",
        "task": {
          "id": "P1.T001",
          "feature_id": "F001",
          "title": "Design Admin Api",
          "description": "Design task for Admin Api",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f001-design.md",
                "docs/api/f001-openapi.yaml",
                "docs/schemas/f001-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Spec published (OpenAPI and/or proto) for Stats, StatsKeys, Peek, PurgeDLQ, PurgeAll, Bench.",
              "script": "test_p1.t001.sh"
            },
            {
              "type": "automated",
              "description": "Auth with deny\u2011by\u2011default; tokens verified; audit log persisted for destructive calls.",
              "script": "test_p1.t001.sh"
            },
            {
              "type": "automated",
              "description": "Rate limits and explicit confirmation flags for destructive actions.",
              "script": "test_p1.t001.sh"
            },
            {
              "type": "manual",
              "description": "Versioned paths; compat notes; structured error schema.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Handler unit tests and integration tests pass in CI.",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/admin-api.md",
              "excerpt": "Define a versioned, secure Admin API (HTTP/gRPC) that fronts existing admin functions, enabling TUI/web/automation with RBAC and observability.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Smart foundatio",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Choose transport: HTTP+JSON (OpenAPI) with optional gRPC; generate clients where useful.",
              "Implement middleware: auth (bearer), rate limiting, request logging, correlation IDs.",
              "Map handlers to `internal/admin` functions; add pagination/validation.",
              "Versioning: `/api/v1`; document compat policy; structured errors.",
              "Observability: metrics (per-endpoint latency/error), audit logs for destructive ops.",
              "Ship minimal clients for TUI/CLI; integration tests with ephemeral Redis."
            ],
            "user_stories": [
              "I can call Stats/Peek/Purge endpoints with auth tokens.",
              "I consume a stable v1 API regardless of internal changes.",
              "I can scope tokens/roles to admin actions."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T002",
        "name": "Implement Admin Api",
        "task": {
          "id": "P1.T002",
          "feature_id": "F001",
          "title": "Implement Admin Api",
          "description": "Implement task for Admin Api",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Spec published (OpenAPI and/or proto) for Stats, StatsKeys, Peek, PurgeDLQ, PurgeAll, Bench.",
                "Auth with deny\u2011by\u2011default; tokens verified; audit log persisted for destructive calls.",
                "Rate limits and explicit confirmation flags for destructive actions."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/admin-api/",
                "internal/admin-api/*_test.go",
                "docs/api/admin-api.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Spec published (OpenAPI and/or proto) for Stats, StatsKeys, Peek, PurgeDLQ, PurgeAll, Bench.",
              "script": "test_p1.t002.sh"
            },
            {
              "type": "automated",
              "description": "Auth with deny\u2011by\u2011default; tokens verified; audit log persisted for destructive calls.",
              "script": "test_p1.t002.sh"
            },
            {
              "type": "automated",
              "description": "Rate limits and explicit confirmation flags for destructive actions.",
              "script": "test_p1.t002.sh"
            },
            {
              "type": "manual",
              "description": "Versioned paths; compat notes; structured error schema.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Handler unit tests and integration tests pass in CI.",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/admin-api.md",
              "excerpt": "Define a versioned, secure Admin API (HTTP/gRPC) that fronts existing admin functions, enabling TUI/web/automation with RBAC and observability.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Smart foundatio",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Draft OpenAPI/proto; agree on schemas",
              "Auth middleware + config",
              "Implement Stats/StatsKeys",
              "Implement Peek",
              "Implement PurgeDLQ/PurgeAll with confirmations",
              "Implement Bench",
              "Add metrics + audit logs",
              "Write unit/integration tests",
              "Wire TUI Stats to API"
            ],
            "technical_approach": [
              "Choose transport: HTTP+JSON (OpenAPI) with optional gRPC; generate clients where useful.",
              "Implement middleware: auth (bearer), rate limiting, request logging, correlation IDs.",
              "Map handlers to `internal/admin` functions; add pagination/validation.",
              "Versioning: `/api/v1`; document compat policy; structured errors.",
              "Observability: metrics (per-endpoint latency/error), audit logs for destructive ops.",
              "Ship minimal clients for TUI/CLI; integration tests with ephemeral Redis."
            ],
            "code_structure": {
              "main_package": "internal/admin-api",
              "files": [
                "admin-api.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            },
            "endpoints": [
              {
                "method": "GET",
                "path": "/api/v1/stats",
                "handler": "GetStats",
                "description": "Return queue statistics (length, processing, DLQ counts)"
              },
              {
                "method": "GET",
                "path": "/api/v1/stats/keys",
                "handler": "GetStatsKeys",
                "description": "List all Redis keys used by queues"
              },
              {
                "method": "GET",
                "path": "/api/v1/queues/{queue}/peek",
                "handler": "PeekQueue",
                "description": "View jobs without removing them",
                "params": "count (optional)"
              },
              {
                "method": "DELETE",
                "path": "/api/v1/queues/{queue}/dlq",
                "handler": "PurgeDLQ",
                "description": "Clear dead letter queue with confirmation"
              },
              {
                "method": "DELETE",
                "path": "/api/v1/queues/all",
                "handler": "PurgeAll",
                "description": "Clear all queues with double confirmation"
              },
              {
                "method": "POST",
                "path": "/api/v1/bench",
                "handler": "RunBenchmark",
                "description": "Run performance benchmarks"
              }
            ],
            "middleware": [
              "Bearer token authentication (validate JWT)",
              "Rate limiting (100 req/min per token)",
              "Request logging with correlation IDs",
              "Audit logging for destructive operations",
              "CORS handler for browser clients",
              "Panic recovery middleware",
              "Timeout handler (30s default)"
            ],
            "auth_requirements": [
              "Bearer token validation",
              "JWT claims extraction",
              "Rate limiting per token",
              "Audit logging"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T003",
        "name": "Test Admin Api",
        "task": {
          "id": "P1.T003",
          "feature_id": "F001",
          "title": "Test Admin Api",
          "description": "Test task for Admin Api",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Spec published (OpenAPI and/or proto) for Stats, StatsKeys, Peek, PurgeDLQ, PurgeAll, Bench.",
              "script": "test_p1.t003.sh"
            },
            {
              "type": "automated",
              "description": "Auth with deny\u2011by\u2011default; tokens verified; audit log persisted for destructive calls.",
              "script": "test_p1.t003.sh"
            },
            {
              "type": "automated",
              "description": "Rate limits and explicit confirmation flags for destructive actions.",
              "script": "test_p1.t003.sh"
            },
            {
              "type": "manual",
              "description": "Versioned paths; compat notes; structured error schema.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Handler unit tests and integration tests pass in CI.",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/admin-api.md",
              "excerpt": "Define a versioned, secure Admin API (HTTP/gRPC) that fronts existing admin functions, enabling TUI/web/automation with RBAC and observability.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Smart foundatio",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: middleware (auth/rate/log) and handlers; fuzz path/query parsing."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: dockerized Redis; golden responses; auth failure/expiry cases."
                ],
                "priority": "high"
              },
              {
                "type": "security",
                "tests": [
                  "Security: basic token leakage and privilege tests."
                ],
                "priority": "medium"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T004",
        "name": "Deploy Admin Api",
        "task": {
          "id": "P1.T004",
          "feature_id": "F001",
          "title": "Deploy Admin Api",
          "description": "Deploy task for Admin Api",
          "boundaries": {
            "expected_complexity": {
              "value": "Configuration and scripts",
              "breakdown": "Docker (50%), K8s manifests (30%), Scripts (20%)"
            },
            "definition_of_done": {
              "criteria": [
                "Deployment successful to staging",
                "Health checks passing",
                "Smoke tests passing",
                "Rollback tested",
                "Monitoring configured",
                "Alerts configured"
              ],
              "stop_when": "Deployed to staging; do NOT deploy to production"
            },
            "scope": {}
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "deployment",
              "kubernetes",
              "monitoring"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": false
          },
          "duration": {
            "optimistic": 1,
            "mostLikely": 2,
            "pessimistic": 4
          },
          "shared_resources": {
            "exclusive_locks": [
              "deployment_slot"
            ],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Spec published (OpenAPI and/or proto) for Stats, StatsKeys, Peek, PurgeDLQ, PurgeAll, Bench.",
              "script": "test_p1.t004.sh"
            },
            {
              "type": "automated",
              "description": "Auth with deny\u2011by\u2011default; tokens verified; audit log persisted for destructive calls.",
              "script": "test_p1.t004.sh"
            },
            {
              "type": "automated",
              "description": "Rate limits and explicit confirmation flags for destructive actions.",
              "script": "test_p1.t004.sh"
            },
            {
              "type": "manual",
              "description": "Versioned paths; compat notes; structured error schema.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Handler unit tests and integration tests pass in CI.",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/admin-api.md",
              "excerpt": "Define a versioned, secure Admin API (HTTP/gRPC) that fronts existing admin functions, enabling TUI/web/automation with RBAC and observability.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Smart foundatio",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ]
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T005",
        "name": "Design Multi Cluster Control",
        "task": {
          "id": "P2.T005",
          "feature_id": "F002",
          "title": "Design Multi Cluster Control",
          "description": "Design task for Multi Cluster Control",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f002-design.md",
                "docs/api/f002-openapi.yaml",
                "docs/schemas/f002-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Multiple clusters configured with labels and colors.",
              "script": "test_p2.t005.sh"
            },
            {
              "type": "automated",
              "description": "Side\u2011by\u2011side compare mode exists for Jobs and Workers.",
              "script": "test_p2.t005.sh"
            },
            {
              "type": "automated",
              "description": "Multi\u2011apply actions require explicit selection and confirmation listing targets.",
              "script": "test_p2.t005.sh"
            },
            {
              "type": "manual",
              "description": "Multi\u2011endpoint config + tabs",
              "script": null
            },
            {
              "type": "manual",
              "description": "Side\u2011by\u2011side compare views",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/multi-cluster-control.md",
              "excerpt": "Manage multiple Redis clusters from a single TUI: quick switch tabs, side\u2011by\u2011side compare, and optionally propagate admin actions across clusters with confirmations.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Config: accept multiple Redis endpoints with labels; hot\u2011switch via `1..9` or mouse tabs.",
              "Compare view: render side\u2011by\u2011side key stats; highlight deltas and anomalies.",
              "Propagate actions: opt\u2011in multi\u2011select clusters for actions (PurgeDLQ, Bench) with explicit confirm.",
              "Caching: per\u2011cluster polling with jitter; summarized health in tab bar.",
              "Observability: cluster\u2011qualified metrics and logs."
            ],
            "user_stories": [
              "I can switch clusters instantly and keep filters/focus.",
              "I can compare queue health across clusters.",
              "I can run an action on selected clusters with clear confirmation."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T006",
        "name": "Implement Multi Cluster Control",
        "task": {
          "id": "P2.T006",
          "feature_id": "F002",
          "title": "Implement Multi Cluster Control",
          "description": "Implement task for Multi Cluster Control",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Multiple clusters configured with labels and colors.",
                "Side\u2011by\u2011side compare mode exists for Jobs and Workers.",
                "Multi\u2011apply actions require explicit selection and confirmation listing targets."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/multi-cluster-control/",
                "internal/multi-cluster-control/*_test.go",
                "docs/api/multi-cluster-control.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Multiple clusters configured with labels and colors.",
              "script": "test_p2.t006.sh"
            },
            {
              "type": "automated",
              "description": "Side\u2011by\u2011side compare mode exists for Jobs and Workers.",
              "script": "test_p2.t006.sh"
            },
            {
              "type": "automated",
              "description": "Multi\u2011apply actions require explicit selection and confirmation listing targets.",
              "script": "test_p2.t006.sh"
            },
            {
              "type": "manual",
              "description": "Multi\u2011endpoint config + tabs",
              "script": null
            },
            {
              "type": "manual",
              "description": "Side\u2011by\u2011side compare views",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/multi-cluster-control.md",
              "excerpt": "Manage multiple Redis clusters from a single TUI: quick switch tabs, side\u2011by\u2011side compare, and optionally propagate admin actions across clusters with confirmations.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Multi\u2011endpoint config + tabs",
              "Side\u2011by\u2011side compare views",
              "Multi\u2011apply action flow + confirmations",
              "Docs"
            ],
            "technical_approach": [
              "Config: accept multiple Redis endpoints with labels; hot\u2011switch via `1..9` or mouse tabs.",
              "Compare view: render side\u2011by\u2011side key stats; highlight deltas and anomalies.",
              "Propagate actions: opt\u2011in multi\u2011select clusters for actions (PurgeDLQ, Bench) with explicit confirm.",
              "Caching: per\u2011cluster polling with jitter; summarized health in tab bar.",
              "Observability: cluster\u2011qualified metrics and logs."
            ],
            "code_structure": {
              "main_package": "internal/multi-cluster-control",
              "files": [
                "multi-cluster-control.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T007",
        "name": "Test Multi Cluster Control",
        "task": {
          "id": "P2.T007",
          "feature_id": "F002",
          "title": "Test Multi Cluster Control",
          "description": "Test task for Multi Cluster Control",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Multiple clusters configured with labels and colors.",
              "script": "test_p2.t007.sh"
            },
            {
              "type": "automated",
              "description": "Side\u2011by\u2011side compare mode exists for Jobs and Workers.",
              "script": "test_p2.t007.sh"
            },
            {
              "type": "automated",
              "description": "Multi\u2011apply actions require explicit selection and confirmation listing targets.",
              "script": "test_p2.t007.sh"
            },
            {
              "type": "manual",
              "description": "Multi\u2011endpoint config + tabs",
              "script": null
            },
            {
              "type": "manual",
              "description": "Side\u2011by\u2011side compare views",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/multi-cluster-control.md",
              "excerpt": "Manage multiple Redis clusters from a single TUI: quick switch tabs, side\u2011by\u2011side compare, and optionally propagate admin actions across clusters with confirmations.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: config parsing; selection logic; confirmation prompts."
                ],
                "priority": "high"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T008",
        "name": "Design Visual Dag Builder",
        "task": {
          "id": "P2.T008",
          "feature_id": "F003",
          "title": "Design Visual Dag Builder",
          "description": "Design task for Visual Dag Builder",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f003-design.md",
                "docs/api/f003-openapi.yaml",
                "docs/schemas/f003-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "DAG validation prevents cycles and missing deps.",
              "script": "test_p2.t008.sh"
            },
            {
              "type": "automated",
              "description": "Runs persist state; survive restarts; resumable.",
              "script": "test_p2.t008.sh"
            },
            {
              "type": "automated",
              "description": "Per-node retry/backoff and optional compensation supported.",
              "script": "test_p2.t008.sh"
            },
            {
              "type": "manual",
              "description": "TUI shows statuses: queued, running, success, failed, compensated.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Define workflow spec (schema + examples)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/visual-dag-builder.md",
              "excerpt": "Design and ship a terminal-native visual builder for multi-step workflows. Users assemble stages with dependencies, retries, and compensations, then submit the DAG as a reusable pipeline. This turns t",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Model: introduce minimal workflow spec (YAML/JSON) with nodes, edges, retry/backoff, compensation, timeout, concurrency caps.",
              "Persistence: store workflow specs under Redis keys or a small metadata store; versioned with hashes.",
              "Execution: add a light orchestrator that enqueues per-node jobs and tracks completion via processing lists/heartbeats.",
              "TUI:",
              "Canvas: grid layout with keyboard navigation; node palette; inspector panel.",
              "Node types: task, decision (conditional), delay/timer, compensation.",
              "Validation: detect cycles, unreachable nodes, unsatisfied dependencies.",
              "Run: submit workflow + parameters; show live state (colors by status).",
              "API: endpoints to create/list/get/version workflows, start run, inspect run state.",
              "Observability: per-run trace ID; per-node timings; failure stats."
            ],
            "user_stories": [
              "I can draw a workflow, validate it, and save it with version notes.",
              "I can start a run with parameters and watch node states update in real time.",
              "I can inspect a failed run and see exactly which node failed and why."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T009",
        "name": "Implement Visual Dag Builder",
        "task": {
          "id": "P2.T009",
          "feature_id": "F003",
          "title": "Implement Visual Dag Builder",
          "description": "Implement task for Visual Dag Builder",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "DAG validation prevents cycles and missing deps.",
                "Runs persist state; survive restarts; resumable.",
                "Per-node retry/backoff and optional compensation supported."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/visual-dag-builder/",
                "internal/visual-dag-builder/*_test.go",
                "docs/api/visual-dag-builder.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "DAG validation prevents cycles and missing deps.",
              "script": "test_p2.t009.sh"
            },
            {
              "type": "automated",
              "description": "Runs persist state; survive restarts; resumable.",
              "script": "test_p2.t009.sh"
            },
            {
              "type": "automated",
              "description": "Per-node retry/backoff and optional compensation supported.",
              "script": "test_p2.t009.sh"
            },
            {
              "type": "manual",
              "description": "TUI shows statuses: queued, running, success, failed, compensated.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Define workflow spec (schema + examples)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/visual-dag-builder.md",
              "excerpt": "Design and ship a terminal-native visual builder for multi-step workflows. Users assemble stages with dependencies, retries, and compensations, then submit the DAG as a reusable pipeline. This turns t",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define workflow spec (schema + examples)",
              "Implement orchestrator (enqueue + state tracking)",
              "Admin API CRUD + run endpoints",
              "TUI canvas + inspector + palette",
              "Live status rendering + colors",
              "Docs + demos"
            ],
            "technical_approach": [
              "Model: introduce minimal workflow spec (YAML/JSON) with nodes, edges, retry/backoff, compensation, timeout, concurrency caps.",
              "Persistence: store workflow specs under Redis keys or a small metadata store; versioned with hashes.",
              "Execution: add a light orchestrator that enqueues per-node jobs and tracks completion via processing lists/heartbeats.",
              "TUI:",
              "Canvas: grid layout with keyboard navigation; node palette; inspector panel.",
              "Node types: task, decision (conditional), delay/timer, compensation.",
              "Validation: detect cycles, unreachable nodes, unsatisfied dependencies.",
              "Run: submit workflow + parameters; show live state (colors by status).",
              "API: endpoints to create/list/get/version workflows, start run, inspect run state.",
              "Observability: per-run trace ID; per-node timings; failure stats."
            ],
            "code_structure": {
              "main_package": "internal/visual-dag-builder",
              "files": [
                "visual-dag-builder.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            },
            "ui_components": [
              "DAG canvas with ASCII rendering",
              "Node palette (task, decision, parallel, loop, compensate)",
              "Properties inspector panel",
              "Keyboard navigation (hjkl movement)",
              "Zoom controls (50-200%)",
              "Live execution status overlay"
            ],
            "dag_operations": [
              "addNode(type, position)",
              "removeNode(nodeId)",
              "connectNodes(from, to, edgeType)",
              "validateDAG() - cycle detection",
              "topologicalSort()",
              "saveWorkflow(name, version)",
              "loadWorkflow(id)",
              "executeWorkflow(params)",
              "getExecutionStatus(runId)"
            ],
            "keyboard_shortcuts": {
              "h/j/k/l": "Navigate",
              "a": "Add node",
              "c": "Connect nodes",
              "d": "Delete",
              "u": "Undo",
              "r": "Redo"
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T010",
        "name": "Test Visual Dag Builder",
        "task": {
          "id": "P2.T010",
          "feature_id": "F003",
          "title": "Test Visual Dag Builder",
          "description": "Test task for Visual Dag Builder",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "DAG validation prevents cycles and missing deps.",
              "script": "test_p2.t010.sh"
            },
            {
              "type": "automated",
              "description": "Runs persist state; survive restarts; resumable.",
              "script": "test_p2.t010.sh"
            },
            {
              "type": "automated",
              "description": "Per-node retry/backoff and optional compensation supported.",
              "script": "test_p2.t010.sh"
            },
            {
              "type": "manual",
              "description": "TUI shows statuses: queued, running, success, failed, compensated.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Define workflow spec (schema + examples)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/visual-dag-builder.md",
              "excerpt": "Design and ship a terminal-native visual builder for multi-step workflows. Users assemble stages with dependencies, retries, and compensations, then submit the DAG as a reusable pipeline. This turns t",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: DAG validation, topo sort, retry/backoff math, compensation trigger."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: end-to-end run with induced failures and resumptions."
                ],
                "priority": "high"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T011",
        "name": "Design Distributed Tracing Integration",
        "task": {
          "id": "P1.T011",
          "feature_id": "F004",
          "title": "Design Distributed Tracing Integration",
          "description": "Design task for Distributed Tracing Integration",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f004-design.md",
                "docs/api/f004-openapi.yaml",
                "docs/schemas/f004-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Spans emitted for enqueue/dequeue/process with consistent attributes.",
              "script": "test_p1.t011.sh"
            },
            {
              "type": "automated",
              "description": "Context propagates via metadata; upstream trace linkage verified.",
              "script": "test_p1.t011.sh"
            },
            {
              "type": "automated",
              "description": "TUI shows trace IDs and open/copy actions.",
              "script": "test_p1.t011.sh"
            },
            {
              "type": "manual",
              "description": "Add otel setup in `internal/obs/tracing.go` with config",
              "script": null
            },
            {
              "type": "manual",
              "description": "Instrument producer/worker/admin critical paths",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/distributed-tracing-integration.md",
              "excerpt": "Make tracing first\u2011class with OpenTelemetry: automatically create spans for enqueue, dequeue, and job processing, propagate context through job payloads/metadata, and link to external tracing backends",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "SDK & instrumentation:",
              "Use `go.opentelemetry.io/otel` across producer, worker, and admin.",
              "Enqueue: start span `queue.enqueue` with attributes (queue, size, priority, tenant, idempotency_id).",
              "Dequeue: span `queue.dequeue` with wait time and queue depth at dequeue.",
              "Process: span `job.process` around user handler; record retries, outcome, error class.",
              "Link parent context if `traceparent`/`tracestate` present in payload metadata; otherwise start a new root and inject on enqueue.",
              "Propagation:",
              "Embed W3C trace headers in job metadata (not payload) to avoid accidental redaction.",
              "Ensure workers extract before processing and reinject on any outbound calls.",
              "Exporters & sampling:",
              "Default OTLP exporter to local Collector; config for endpoints/auth.",
              "Head sampling with per\u2011route/queue rates; tail sampling via Collector for high\u2011value spans (errors, long latency).",
              "Metrics + exemplars:",
              "Attach trace IDs to latency/error metrics as exemplars when sampled.",
              "TUI integration:",
              "Show trace ID in Peek/Info; provide an \u201cOpen Trace\u201d action and copyable link; enable quick filter by trace ID.",
              "Security & privacy:",
              "Redact sensitive attributes; configurable allowlist for span attributes.",
              "Disable/limit tracing in prod via config and sampling controls."
            ],
            "user_stories": [
              "I can open the trace for a failed job directly from the TUI.",
              "I can see queueing time vs processing time for a class of jobs."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T012",
        "name": "Implement Distributed Tracing Integration",
        "task": {
          "id": "P1.T012",
          "feature_id": "F004",
          "title": "Implement Distributed Tracing Integration",
          "description": "Implement task for Distributed Tracing Integration",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Spans emitted for enqueue/dequeue/process with consistent attributes.",
                "Context propagates via metadata; upstream trace linkage verified.",
                "TUI shows trace IDs and open/copy actions."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/distributed-tracing-integration/",
                "internal/distributed-tracing-integration/*_test.go",
                "docs/api/distributed-tracing-integration.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Spans emitted for enqueue/dequeue/process with consistent attributes.",
              "script": "test_p1.t012.sh"
            },
            {
              "type": "automated",
              "description": "Context propagates via metadata; upstream trace linkage verified.",
              "script": "test_p1.t012.sh"
            },
            {
              "type": "automated",
              "description": "TUI shows trace IDs and open/copy actions.",
              "script": "test_p1.t012.sh"
            },
            {
              "type": "manual",
              "description": "Add otel setup in `internal/obs/tracing.go` with config",
              "script": null
            },
            {
              "type": "manual",
              "description": "Instrument producer/worker/admin critical paths",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/distributed-tracing-integration.md",
              "excerpt": "Make tracing first\u2011class with OpenTelemetry: automatically create spans for enqueue, dequeue, and job processing, propagate context through job payloads/metadata, and link to external tracing backends",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Add otel setup in `internal/obs/tracing.go` with config",
              "Instrument producer/worker/admin critical paths",
              "Inject/extract trace headers in metadata",
              "Add TUI trace actions in Peek/Info",
              "Docs with backend examples and sampling guidance"
            ],
            "technical_approach": [
              "SDK & instrumentation:",
              "Use `go.opentelemetry.io/otel` across producer, worker, and admin.",
              "Enqueue: start span `queue.enqueue` with attributes (queue, size, priority, tenant, idempotency_id).",
              "Dequeue: span `queue.dequeue` with wait time and queue depth at dequeue.",
              "Process: span `job.process` around user handler; record retries, outcome, error class.",
              "Link parent context if `traceparent`/`tracestate` present in payload metadata; otherwise start a new root and inject on enqueue.",
              "Propagation:",
              "Embed W3C trace headers in job metadata (not payload) to avoid accidental redaction.",
              "Ensure workers extract before processing and reinject on any outbound calls.",
              "Exporters & sampling:",
              "Default OTLP exporter to local Collector; config for endpoints/auth.",
              "Head sampling with per\u2011route/queue rates; tail sampling via Collector for high\u2011value spans (errors, long latency).",
              "Metrics + exemplars:",
              "Attach trace IDs to latency/error metrics as exemplars when sampled.",
              "TUI integration:",
              "Show trace ID in Peek/Info; provide an \u201cOpen Trace\u201d action and copyable link; enable quick filter by trace ID.",
              "Security & privacy:",
              "Redact sensitive attributes; configurable allowlist for span attributes.",
              "Disable/limit tracing in prod via config and sampling controls."
            ],
            "code_structure": {
              "main_package": "internal/distributed-tracing-integration",
              "files": [
                "distributed-tracing-integration.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            },
            "tracing_components": [
              "OpenTelemetry SDK integration",
              "Trace context propagation (W3C format)",
              "Span management (create, end, annotate)",
              "Baggage propagation for metadata",
              "Sampling strategies (always, probabilistic, adaptive)",
              "Exporters (Jaeger, Zipkin, OTLP)",
              "Metrics correlation"
            ],
            "context_propagation": [
              "Extract trace context from incoming requests",
              "Inject context into outgoing requests",
              "Create child spans for operations",
              "Add span attributes and events"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T013",
        "name": "Test Distributed Tracing Integration",
        "task": {
          "id": "P1.T013",
          "feature_id": "F004",
          "title": "Test Distributed Tracing Integration",
          "description": "Test task for Distributed Tracing Integration",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Spans emitted for enqueue/dequeue/process with consistent attributes.",
              "script": "test_p1.t013.sh"
            },
            {
              "type": "automated",
              "description": "Context propagates via metadata; upstream trace linkage verified.",
              "script": "test_p1.t013.sh"
            },
            {
              "type": "automated",
              "description": "TUI shows trace IDs and open/copy actions.",
              "script": "test_p1.t013.sh"
            },
            {
              "type": "manual",
              "description": "Add otel setup in `internal/obs/tracing.go` with config",
              "script": null
            },
            {
              "type": "manual",
              "description": "Instrument producer/worker/admin critical paths",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/distributed-tracing-integration.md",
              "excerpt": "Make tracing first\u2011class with OpenTelemetry: automatically create spans for enqueue, dequeue, and job processing, propagate context through job payloads/metadata, and link to external tracing backends",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: propagation helpers; attribute sets; error recording."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: OTLP to Collector; verify parent/child linkage across enqueue\u2192process."
                ],
                "priority": "high"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T014",
        "name": "Deploy Distributed Tracing Integration",
        "task": {
          "id": "P1.T014",
          "feature_id": "F004",
          "title": "Deploy Distributed Tracing Integration",
          "description": "Deploy task for Distributed Tracing Integration",
          "boundaries": {
            "expected_complexity": {
              "value": "Configuration and scripts",
              "breakdown": "Docker (50%), K8s manifests (30%), Scripts (20%)"
            },
            "definition_of_done": {
              "criteria": [
                "Deployment successful to staging",
                "Health checks passing",
                "Smoke tests passing",
                "Rollback tested",
                "Monitoring configured",
                "Alerts configured"
              ],
              "stop_when": "Deployed to staging; do NOT deploy to production"
            },
            "scope": {}
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "deployment",
              "kubernetes",
              "monitoring"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": false
          },
          "duration": {
            "optimistic": 1,
            "mostLikely": 2,
            "pessimistic": 4
          },
          "shared_resources": {
            "exclusive_locks": [
              "deployment_slot"
            ],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Spans emitted for enqueue/dequeue/process with consistent attributes.",
              "script": "test_p1.t014.sh"
            },
            {
              "type": "automated",
              "description": "Context propagates via metadata; upstream trace linkage verified.",
              "script": "test_p1.t014.sh"
            },
            {
              "type": "automated",
              "description": "TUI shows trace IDs and open/copy actions.",
              "script": "test_p1.t014.sh"
            },
            {
              "type": "manual",
              "description": "Add otel setup in `internal/obs/tracing.go` with config",
              "script": null
            },
            {
              "type": "manual",
              "description": "Instrument producer/worker/admin critical paths",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/distributed-tracing-integration.md",
              "excerpt": "Make tracing first\u2011class with OpenTelemetry: automatically create spans for enqueue, dequeue, and job processing, propagate context through job payloads/metadata, and link to external tracing backends",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ]
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T015",
        "name": "Design Plugin Panel System",
        "task": {
          "id": "P4.T015",
          "feature_id": "F005",
          "title": "Design Plugin Panel System",
          "description": "Design task for Plugin Panel System",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f005-design.md",
                "docs/api/f005-openapi.yaml",
                "docs/schemas/f005-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Host loads/isolates plugins with manifest validation and resource limits.",
              "script": "test_p4.t015.sh"
            },
            {
              "type": "automated",
              "description": "Capability prompts on first run; persisted decisions per plugin version.",
              "script": "test_p4.t015.sh"
            },
            {
              "type": "automated",
              "description": "Stable v1 API documented with examples in WASM and Lua/Starlark.",
              "script": "test_p4.t015.sh"
            },
            {
              "type": "manual",
              "description": "Two sample plugins shipped and tested.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Define host API + capability model",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/plugin-panel-system.md",
              "excerpt": "A terminal\u2011native plugin framework that lets teams drop in custom panels for org\u2011specific metrics, transforms, and actions. Plugins render inside the TUI, receive typed events (stats, selection, timer",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Runtime: start with WASM (TinyGo) or Starlark/Lua for safety and portability; avoid Go `plugin` due to portability issues.",
              "API Surface (capability\u2011gated):",
              "Read\u2011only: subscribe to stats, keys, selection, timers.",
              "Actions: enqueue, peek, requeue, purge (require explicit user grant per plugin).",
              "UI: render text blocks with styles; receive keyboard/mouse events in plugin\u2019s zone.",
              "Packaging: plugin bundle = `manifest.yaml` (name, version, permissions, entry), bytecode/script, optional assets.",
              "Lifecycle: discover under `plugins/`, validate manifest + permissions, load sandbox, render panel region; hot\u2011reload on file change.",
              "Sandboxing: CPU/memory/time limits; deny filesystem/network by default; only brokered API calls allowed.",
              "Versioning: semantic version the host/plugin API; shims for minor changes; e2e contract tests.",
              "Samples: \u201cTenant SLA\u201d read\u2011only panel; \u201cBulk Requeue Helper\u201d action panel (cap\u2011gated)."
            ],
            "user_stories": [
              "I can enable a plugin and see its panel render without crashing the TUI.",
              "I can inspect requested permissions and approve/deny.",
              "I can build a plugin with typed events, test locally, and hot\u2011reload."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T016",
        "name": "Implement Plugin Panel System",
        "task": {
          "id": "P4.T016",
          "feature_id": "F005",
          "title": "Implement Plugin Panel System",
          "description": "Implement task for Plugin Panel System",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Host loads/isolates plugins with manifest validation and resource limits.",
                "Capability prompts on first run; persisted decisions per plugin version.",
                "Stable v1 API documented with examples in WASM and Lua/Starlark."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/plugin-panel-system/",
                "internal/plugin-panel-system/*_test.go",
                "docs/api/plugin-panel-system.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Host loads/isolates plugins with manifest validation and resource limits.",
              "script": "test_p4.t016.sh"
            },
            {
              "type": "automated",
              "description": "Capability prompts on first run; persisted decisions per plugin version.",
              "script": "test_p4.t016.sh"
            },
            {
              "type": "automated",
              "description": "Stable v1 API documented with examples in WASM and Lua/Starlark.",
              "script": "test_p4.t016.sh"
            },
            {
              "type": "manual",
              "description": "Two sample plugins shipped and tested.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Define host API + capability model",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/plugin-panel-system.md",
              "excerpt": "A terminal\u2011native plugin framework that lets teams drop in custom panels for org\u2011specific metrics, transforms, and actions. Plugins render inside the TUI, receive typed events (stats, selection, timer",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define host API + capability model",
              "Choose runtime (WASM + Starlark) and embed",
              "Implement loader, sandbox, event bus",
              "Implement renderer adapter (panel zone)",
              "Add permission UI + persistence",
              "Build sample plugins + docs"
            ],
            "technical_approach": [
              "Runtime: start with WASM (TinyGo) or Starlark/Lua for safety and portability; avoid Go `plugin` due to portability issues.",
              "API Surface (capability\u2011gated):",
              "Read\u2011only: subscribe to stats, keys, selection, timers.",
              "Actions: enqueue, peek, requeue, purge (require explicit user grant per plugin).",
              "UI: render text blocks with styles; receive keyboard/mouse events in plugin\u2019s zone.",
              "Packaging: plugin bundle = `manifest.yaml` (name, version, permissions, entry), bytecode/script, optional assets.",
              "Lifecycle: discover under `plugins/`, validate manifest + permissions, load sandbox, render panel region; hot\u2011reload on file change.",
              "Sandboxing: CPU/memory/time limits; deny filesystem/network by default; only brokered API calls allowed.",
              "Versioning: semantic version the host/plugin API; shims for minor changes; e2e contract tests.",
              "Samples: \u201cTenant SLA\u201d read\u2011only panel; \u201cBulk Requeue Helper\u201d action panel (cap\u2011gated)."
            ],
            "code_structure": {
              "main_package": "internal/plugin-panel-system",
              "files": [
                "plugin-panel-system.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T017",
        "name": "Design Time Travel Debugger",
        "task": {
          "id": "P4.T017",
          "feature_id": "F006",
          "title": "Design Time Travel Debugger",
          "description": "Design task for Time Travel Debugger",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f006-design.md",
                "docs/api/f006-openapi.yaml",
                "docs/schemas/f006-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Complete execution history captured without >5% performance impact",
              "script": "test_p4.t017.sh"
            },
            {
              "type": "automated",
              "description": "Replay controls work smoothly in TUI with <100ms response time",
              "script": "test_p4.t017.sh"
            },
            {
              "type": "automated",
              "description": "Can export and share replay sessions",
              "script": "test_p4.t017.sh"
            },
            {
              "type": "manual",
              "description": "Historical data automatically pruned based on retention policy",
              "script": null
            },
            {
              "type": "manual",
              "description": "Design event schema and storage strategy",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/time-travel-debugger.md",
              "excerpt": "A revolutionary debugging tool that captures job execution history and allows developers to replay, step through, and analyze past job runs in the TUI. Navigate through time to see exact states, varia",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Event Capture:",
              "Record all state transitions with timestamps (enqueue, start, retry, complete, fail)",
              "Capture snapshots of payload, worker state, Redis state at key moments",
              "Use ring buffer with configurable retention (e.g., last 1000 jobs or 24 hours)",
              "Compress and store in Redis Streams or separate time-series store",
              "Replay Engine:",
              "Reconstruct exact execution timeline from events",
              "Support play/pause/step/rewind with variable speed",
              "Show state diffs between steps",
              "Highlight decision points (retry logic, routing, etc.)",
              "TUI Integration:",
              "Timeline scrubber with keyboard (h/l for back/forward, space to play/pause)",
              "Split view: current state vs. historical state",
              "Breadcrumb trail of execution path",
              "\"Jump to failure\" shortcuts",
              "Analysis Tools:",
              "Compare multiple job runs side-by-side",
              "Pattern detection across similar failures",
              "Export replay sessions for sharing/training",
              "Performance:",
              "Async event capture to avoid blocking job processing",
              "Sampling options for high-volume queues",
              "Automatic pruning of old events"
            ],
            "user_stories": [
              "I can replay a failed production job locally to understand what went wrong",
              "I can step through the exact sequence of events during an incident",
              "I can use historical replays for training and code reviews"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T018",
        "name": "Implement Time Travel Debugger",
        "task": {
          "id": "P4.T018",
          "feature_id": "F006",
          "title": "Implement Time Travel Debugger",
          "description": "Implement task for Time Travel Debugger",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Complete execution history captured without >5% performance impact",
                "Replay controls work smoothly in TUI with <100ms response time",
                "Can export and share replay sessions"
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/time-travel-debugger/",
                "internal/time-travel-debugger/*_test.go",
                "docs/api/time-travel-debugger.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Complete execution history captured without >5% performance impact",
              "script": "test_p4.t018.sh"
            },
            {
              "type": "automated",
              "description": "Replay controls work smoothly in TUI with <100ms response time",
              "script": "test_p4.t018.sh"
            },
            {
              "type": "automated",
              "description": "Can export and share replay sessions",
              "script": "test_p4.t018.sh"
            },
            {
              "type": "manual",
              "description": "Historical data automatically pruned based on retention policy",
              "script": null
            },
            {
              "type": "manual",
              "description": "Design event schema and storage strategy",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/time-travel-debugger.md",
              "excerpt": "A revolutionary debugging tool that captures job execution history and allows developers to replay, step through, and analyze past job runs in the TUI. Navigate through time to see exact states, varia",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Design event schema and storage strategy",
              "Implement event capture middleware",
              "Build timeline reconstruction engine",
              "Create TUI replay interface",
              "Add comparison and analysis tools",
              "Performance optimization pass",
              "Documentation and examples"
            ],
            "technical_approach": [
              "Event Capture:",
              "Record all state transitions with timestamps (enqueue, start, retry, complete, fail)",
              "Capture snapshots of payload, worker state, Redis state at key moments",
              "Use ring buffer with configurable retention (e.g., last 1000 jobs or 24 hours)",
              "Compress and store in Redis Streams or separate time-series store",
              "Replay Engine:",
              "Reconstruct exact execution timeline from events",
              "Support play/pause/step/rewind with variable speed",
              "Show state diffs between steps",
              "Highlight decision points (retry logic, routing, etc.)",
              "TUI Integration:",
              "Timeline scrubber with keyboard (h/l for back/forward, space to play/pause)",
              "Split view: current state vs. historical state",
              "Breadcrumb trail of execution path",
              "\"Jump to failure\" shortcuts",
              "Analysis Tools:",
              "Compare multiple job runs side-by-side",
              "Pattern detection across similar failures",
              "Export replay sessions for sharing/training",
              "Performance:",
              "Async event capture to avoid blocking job processing",
              "Sampling options for high-volume queues",
              "Automatic pruning of old events"
            ],
            "code_structure": {
              "main_package": "internal/time-travel-debugger",
              "files": [
                "time-travel-debugger.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T019",
        "name": "Design Exactly Once Patterns",
        "task": {
          "id": "P1.T019",
          "feature_id": "F007",
          "title": "Design Exactly Once Patterns",
          "description": "Design task for Exactly Once Patterns",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f007-design.md",
                "docs/api/f007-openapi.yaml",
                "docs/schemas/f007-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Idempotency helpers and dedup storage shipped with metrics.",
              "script": "test_p1.t019.sh"
            },
            {
              "type": "automated",
              "description": "Optional outbox relay with sample integrations.",
              "script": "test_p1.t019.sh"
            },
            {
              "type": "automated",
              "description": "Documentation of tradeoffs and failure modes.",
              "script": "test_p1.t019.sh"
            },
            {
              "type": "manual",
              "description": "Idempotency key helper + storage",
              "script": null
            },
            {
              "type": "manual",
              "description": "Metrics + Admin API for dedup stats",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/exactly-once-patterns.md",
              "excerpt": "Document and optionally enforce patterns for effectively exactly\u2011once processing: idempotency keys, deduplication sets, and the transactional outbox. Provide helpers and guardrails so teams can adopt ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Idempotency keys:",
              "Producer attaches `id` per job; worker records `id` in a dedup set/hash with TTL.",
              "Before side effects, perform `SETNX`/`HSETNX` style guard; on success, proceed; else skip.",
              "Dedup store:",
              "Redis SET/HASH keyed by queue/tenant; TTL for practical bounds; cardinality metrics.",
              "Outbox pattern:",
              "Provide library hooks to write DB changes + outbox event in one transaction.",
              "Separate relay publishes from outbox to queue; worker idempotency still checked.",
              "Helpers:",
              "Go utilities for idempotency check/update and outbox relay; Admin API to inspect dedup stats.",
              "TUI:",
              "Info panel: idempotency hit rate; dedup size; recent duplicates avoided."
            ],
            "user_stories": [
              "I can mark jobs with an idempotency key and rely on helpers to avoid duplicate processing.",
              "I can see dedup rates and size to tune TTLs."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T020",
        "name": "Implement Exactly Once Patterns",
        "task": {
          "id": "P1.T020",
          "feature_id": "F007",
          "title": "Implement Exactly Once Patterns",
          "description": "Implement task for Exactly Once Patterns",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Idempotency helpers and dedup storage shipped with metrics.",
                "Optional outbox relay with sample integrations.",
                "Documentation of tradeoffs and failure modes."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/exactly-once-patterns/",
                "internal/exactly-once-patterns/*_test.go",
                "docs/api/exactly-once-patterns.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Idempotency helpers and dedup storage shipped with metrics.",
              "script": "test_p1.t020.sh"
            },
            {
              "type": "automated",
              "description": "Optional outbox relay with sample integrations.",
              "script": "test_p1.t020.sh"
            },
            {
              "type": "automated",
              "description": "Documentation of tradeoffs and failure modes.",
              "script": "test_p1.t020.sh"
            },
            {
              "type": "manual",
              "description": "Idempotency key helper + storage",
              "script": null
            },
            {
              "type": "manual",
              "description": "Metrics + Admin API for dedup stats",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/exactly-once-patterns.md",
              "excerpt": "Document and optionally enforce patterns for effectively exactly\u2011once processing: idempotency keys, deduplication sets, and the transactional outbox. Provide helpers and guardrails so teams can adopt ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Idempotency key helper + storage",
              "Metrics + Admin API for dedup stats",
              "Outbox relay library + example",
              "Docs + tuning guide"
            ],
            "technical_approach": [
              "Idempotency keys:",
              "Producer attaches `id` per job; worker records `id` in a dedup set/hash with TTL.",
              "Before side effects, perform `SETNX`/`HSETNX` style guard; on success, proceed; else skip.",
              "Dedup store:",
              "Redis SET/HASH keyed by queue/tenant; TTL for practical bounds; cardinality metrics.",
              "Outbox pattern:",
              "Provide library hooks to write DB changes + outbox event in one transaction.",
              "Separate relay publishes from outbox to queue; worker idempotency still checked.",
              "Helpers:",
              "Go utilities for idempotency check/update and outbox relay; Admin API to inspect dedup stats.",
              "TUI:",
              "Info panel: idempotency hit rate; dedup size; recent duplicates avoided."
            ],
            "code_structure": {
              "main_package": "internal/exactly-once-patterns",
              "files": [
                "exactly-once-patterns.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T021",
        "name": "Test Exactly Once Patterns",
        "task": {
          "id": "P1.T021",
          "feature_id": "F007",
          "title": "Test Exactly Once Patterns",
          "description": "Test task for Exactly Once Patterns",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Idempotency helpers and dedup storage shipped with metrics.",
              "script": "test_p1.t021.sh"
            },
            {
              "type": "automated",
              "description": "Optional outbox relay with sample integrations.",
              "script": "test_p1.t021.sh"
            },
            {
              "type": "automated",
              "description": "Documentation of tradeoffs and failure modes.",
              "script": "test_p1.t021.sh"
            },
            {
              "type": "manual",
              "description": "Idempotency key helper + storage",
              "script": null
            },
            {
              "type": "manual",
              "description": "Metrics + Admin API for dedup stats",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/exactly-once-patterns.md",
              "excerpt": "Document and optionally enforce patterns for effectively exactly\u2011once processing: idempotency keys, deduplication sets, and the transactional outbox. Provide helpers and guardrails so teams can adopt ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: dedup guard correctness; TTL expiry edge cases; outbox relay idempotency."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: duplicate injection tests under load; DB+outbox transaction demo."
                ],
                "priority": "high"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T022",
        "name": "Deploy Exactly Once Patterns",
        "task": {
          "id": "P1.T022",
          "feature_id": "F007",
          "title": "Deploy Exactly Once Patterns",
          "description": "Deploy task for Exactly Once Patterns",
          "boundaries": {
            "expected_complexity": {
              "value": "Configuration and scripts",
              "breakdown": "Docker (50%), K8s manifests (30%), Scripts (20%)"
            },
            "definition_of_done": {
              "criteria": [
                "Deployment successful to staging",
                "Health checks passing",
                "Smoke tests passing",
                "Rollback tested",
                "Monitoring configured",
                "Alerts configured"
              ],
              "stop_when": "Deployed to staging; do NOT deploy to production"
            },
            "scope": {}
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "deployment",
              "kubernetes",
              "monitoring"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": false
          },
          "duration": {
            "optimistic": 1,
            "mostLikely": 2,
            "pessimistic": 4
          },
          "shared_resources": {
            "exclusive_locks": [
              "deployment_slot"
            ],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Idempotency helpers and dedup storage shipped with metrics.",
              "script": "test_p1.t022.sh"
            },
            {
              "type": "automated",
              "description": "Optional outbox relay with sample integrations.",
              "script": "test_p1.t022.sh"
            },
            {
              "type": "automated",
              "description": "Documentation of tradeoffs and failure modes.",
              "script": "test_p1.t022.sh"
            },
            {
              "type": "manual",
              "description": "Idempotency key helper + storage",
              "script": null
            },
            {
              "type": "manual",
              "description": "Metrics + Admin API for dedup stats",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/exactly-once-patterns.md",
              "excerpt": "Document and optionally enforce patterns for effectively exactly\u2011once processing: idempotency keys, deduplication sets, and the transactional outbox. Provide helpers and guardrails so teams can adopt ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ]
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T023",
        "name": "Design Rbac And Tokens",
        "task": {
          "id": "P1.T023",
          "feature_id": "F008",
          "title": "Design Rbac And Tokens",
          "description": "Design task for Rbac And Tokens",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f008-design.md",
                "docs/api/f008-openapi.yaml",
                "docs/schemas/f008-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Auth middleware validates tokens with rotation and `kid`.",
              "script": "test_p1.t023.sh"
            },
            {
              "type": "automated",
              "description": "Scope checks enforced for all Admin API endpoints.",
              "script": "test_p1.t023.sh"
            },
            {
              "type": "automated",
              "description": "Audit entries recorded and retrievable with filters.",
              "script": "test_p1.t023.sh"
            },
            {
              "type": "manual",
              "description": "Define roles/scopes and resource patterns",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement token library + middleware",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/rbac-and-tokens.md",
              "excerpt": "Introduce role\u2011based access control and signed tokens over the Admin API. Scope access by action and resource, enforce deny\u2011by\u2011default, and maintain an auditable trail of destructive operations.\n\n> [!",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Token format: PASETO (v2 local/public) or JWT with HMAC; include `sub`, `roles`, `scopes`, `exp`, `iat`.",
              "Roles and scopes:",
              "Roles: viewer, operator, maintainer, admin.",
              "Scopes map to endpoints/actions (e.g., `stats:read`, `enqueue:write`, `dlq:purge`).",
              "Resource constraints: per\u2011queue or prefix, per\u2011cluster.",
              "Middleware:",
              "Verify token signature; check expiry and NBF.",
              "Authorize by scopes/role; record decision with request hash.",
              "Correlate request ID for audit link.",
              "Key management:",
              "Support multiple keys (kid) with rotation.",
              "Offline issuance tool; short\u2011lived tokens; revocation list cache.",
              "Audit log:",
              "Append structured entries for destructive ops (who/what/why/result).",
              "Expose via Admin API with time range; redact sensitive values.",
              "TUI/CLI:",
              "Token info panel (who am I, roles, expiry); helpful errors for denied actions."
            ],
            "user_stories": [
              "I can issue a token with `stats:read` and no destructive scopes.",
              "I can perform allowed actions and see denied ones fail clearly.",
              "I can list purge/requeue actions with actor and timestamp."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T024",
        "name": "Implement Rbac And Tokens",
        "task": {
          "id": "P1.T024",
          "feature_id": "F008",
          "title": "Implement Rbac And Tokens",
          "description": "Implement task for Rbac And Tokens",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Auth middleware validates tokens with rotation and `kid`.",
                "Scope checks enforced for all Admin API endpoints.",
                "Audit entries recorded and retrievable with filters."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/rbac-and-tokens/",
                "internal/rbac-and-tokens/*_test.go",
                "docs/api/rbac-and-tokens.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Auth middleware validates tokens with rotation and `kid`.",
              "script": "test_p1.t024.sh"
            },
            {
              "type": "automated",
              "description": "Scope checks enforced for all Admin API endpoints.",
              "script": "test_p1.t024.sh"
            },
            {
              "type": "automated",
              "description": "Audit entries recorded and retrievable with filters.",
              "script": "test_p1.t024.sh"
            },
            {
              "type": "manual",
              "description": "Define roles/scopes and resource patterns",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement token library + middleware",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/rbac-and-tokens.md",
              "excerpt": "Introduce role\u2011based access control and signed tokens over the Admin API. Scope access by action and resource, enforce deny\u2011by\u2011default, and maintain an auditable trail of destructive operations.\n\n> [!",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define roles/scopes and resource patterns",
              "Implement token library + middleware",
              "Add audit log sink + API",
              "Update handlers to enforce scopes",
              "CLI issuance tool + docs"
            ],
            "technical_approach": [
              "Token format: PASETO (v2 local/public) or JWT with HMAC; include `sub`, `roles`, `scopes`, `exp`, `iat`.",
              "Roles and scopes:",
              "Roles: viewer, operator, maintainer, admin.",
              "Scopes map to endpoints/actions (e.g., `stats:read`, `enqueue:write`, `dlq:purge`).",
              "Resource constraints: per\u2011queue or prefix, per\u2011cluster.",
              "Middleware:",
              "Verify token signature; check expiry and NBF.",
              "Authorize by scopes/role; record decision with request hash.",
              "Correlate request ID for audit link.",
              "Key management:",
              "Support multiple keys (kid) with rotation.",
              "Offline issuance tool; short\u2011lived tokens; revocation list cache.",
              "Audit log:",
              "Append structured entries for destructive ops (who/what/why/result).",
              "Expose via Admin API with time range; redact sensitive values.",
              "TUI/CLI:",
              "Token info panel (who am I, roles, expiry); helpful errors for denied actions."
            ],
            "code_structure": {
              "main_package": "internal/rbac-and-tokens",
              "files": [
                "rbac-and-tokens.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            },
            "auth_model": {
              "roles": [
                "admin",
                "operator",
                "developer",
                "viewer"
              ],
              "permissions": [
                "queue:read",
                "queue:write",
                "queue:delete",
                "job:read",
                "job:write",
                "job:delete",
                "worker:read",
                "worker:manage",
                "admin:all"
              ],
              "token_types": [
                "bearer",
                "api_key",
                "session"
              ],
              "token_lifecycle": [
                "generate",
                "validate",
                "refresh",
                "revoke"
              ]
            },
            "token_lifecycle": [
              "Generate tokens with claims",
              "Validate token signatures",
              "Refresh expired tokens",
              "Revoke compromised tokens",
              "Track token usage"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T025",
        "name": "Test Rbac And Tokens",
        "task": {
          "id": "P1.T025",
          "feature_id": "F008",
          "title": "Test Rbac And Tokens",
          "description": "Test task for Rbac And Tokens",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Auth middleware validates tokens with rotation and `kid`.",
              "script": "test_p1.t025.sh"
            },
            {
              "type": "automated",
              "description": "Scope checks enforced for all Admin API endpoints.",
              "script": "test_p1.t025.sh"
            },
            {
              "type": "automated",
              "description": "Audit entries recorded and retrievable with filters.",
              "script": "test_p1.t025.sh"
            },
            {
              "type": "manual",
              "description": "Define roles/scopes and resource patterns",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement token library + middleware",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/rbac-and-tokens.md",
              "excerpt": "Introduce role\u2011based access control and signed tokens over the Admin API. Scope access by action and resource, enforce deny\u2011by\u2011default, and maintain an auditable trail of destructive operations.\n\n> [!",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: scope matcher; token validation; time skew; revocation."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: end\u2011to\u2011end calls with different roles and resource filters."
                ],
                "priority": "high"
              },
              {
                "type": "security",
                "tests": [
                  "Security: fuzz headers; attempt scope escalation; replay detection."
                ],
                "priority": "medium"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P1.T026",
        "name": "Deploy Rbac And Tokens",
        "task": {
          "id": "P1.T026",
          "feature_id": "F008",
          "title": "Deploy Rbac And Tokens",
          "description": "Deploy task for Rbac And Tokens",
          "boundaries": {
            "expected_complexity": {
              "value": "Configuration and scripts",
              "breakdown": "Docker (50%), K8s manifests (30%), Scripts (20%)"
            },
            "definition_of_done": {
              "criteria": [
                "Deployment successful to staging",
                "Health checks passing",
                "Smoke tests passing",
                "Rollback tested",
                "Monitoring configured",
                "Alerts configured"
              ],
              "stop_when": "Deployed to staging; do NOT deploy to production"
            },
            "scope": {}
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "deployment",
              "kubernetes",
              "monitoring"
            ]
          },
          "scheduling_hints": {
            "priority": "high",
            "preemptible": false,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": false
          },
          "duration": {
            "optimistic": 1,
            "mostLikely": 2,
            "pessimistic": 4
          },
          "shared_resources": {
            "exclusive_locks": [
              "deployment_slot"
            ],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Auth middleware validates tokens with rotation and `kid`.",
              "script": "test_p1.t026.sh"
            },
            {
              "type": "automated",
              "description": "Scope checks enforced for all Admin API endpoints.",
              "script": "test_p1.t026.sh"
            },
            {
              "type": "automated",
              "description": "Audit entries recorded and retrievable with filters.",
              "script": "test_p1.t026.sh"
            },
            {
              "type": "manual",
              "description": "Define roles/scopes and resource patterns",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement token library + middleware",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/rbac-and-tokens.md",
              "excerpt": "Introduce role\u2011based access control and signed tokens over the Admin API. Scope access by action and resource, enforce deny\u2011by\u2011default, and maintain an auditable trail of destructive operations.\n\n> [!",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ]
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T027",
        "name": "Design Chaos Harness",
        "task": {
          "id": "P4.T027",
          "feature_id": "F009",
          "title": "Design Chaos Harness",
          "description": "Design task for Chaos Harness",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f009-design.md",
                "docs/api/f009-openapi.yaml",
                "docs/schemas/f009-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Worker injectors controllable via Admin API with scopes/TTLs.",
              "script": "test_p4.t027.sh"
            },
            {
              "type": "automated",
              "description": "Scenario runner orchestrates injectors and records metrics.",
              "script": "test_p4.t027.sh"
            },
            {
              "type": "automated",
              "description": "TUI surfaces status and recovers settings.",
              "script": "test_p4.t027.sh"
            },
            {
              "type": "manual",
              "description": "Implement worker injectors + API",
              "script": null
            },
            {
              "type": "manual",
              "description": "Add Redis proxy hooks (optional)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/chaos-harness.md",
              "excerpt": "Inject controlled failures (latency, drops, Redis failovers) to test resilience and visualize recovery in the TUI. Automate soak and chaos scenarios with guardrails.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Fault injectors:",
              "Worker: delays, random failures by rate, panic/restart, partial processing.",
              "Redis: optional proxy to inject latency/drops; simulate failover (sentinel/cluster).",
              "Admin API: toggles to enable injectors with TTLs and scopes.",
              "Scenario runner:",
              "Define scenarios (duration, patterns) and run/record outcomes.",
              "Integrate with Patterned Load Generator for mixed stress.",
              "TUI:",
              "Scenario picker; live status; recovery metrics (backlog drain time, error rate).",
              "Visual markers on charts during injections.",
              "Guardrails:",
              "\u201cChaos mode\u201d banner; require typed confirmation; lock out in prod by policy."
            ],
            "user_stories": [
              "I can run a 5\u2011minute latency+drop scenario in staging and see recovery time and DLQ impact."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T028",
        "name": "Implement Chaos Harness",
        "task": {
          "id": "P4.T028",
          "feature_id": "F009",
          "title": "Implement Chaos Harness",
          "description": "Implement task for Chaos Harness",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Worker injectors controllable via Admin API with scopes/TTLs.",
                "Scenario runner orchestrates injectors and records metrics.",
                "TUI surfaces status and recovers settings."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/chaos-harness/",
                "internal/chaos-harness/*_test.go",
                "docs/api/chaos-harness.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Worker injectors controllable via Admin API with scopes/TTLs.",
              "script": "test_p4.t028.sh"
            },
            {
              "type": "automated",
              "description": "Scenario runner orchestrates injectors and records metrics.",
              "script": "test_p4.t028.sh"
            },
            {
              "type": "automated",
              "description": "TUI surfaces status and recovers settings.",
              "script": "test_p4.t028.sh"
            },
            {
              "type": "manual",
              "description": "Implement worker injectors + API",
              "script": null
            },
            {
              "type": "manual",
              "description": "Add Redis proxy hooks (optional)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/chaos-harness.md",
              "excerpt": "Inject controlled failures (latency, drops, Redis failovers) to test resilience and visualize recovery in the TUI. Automate soak and chaos scenarios with guardrails.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Implement worker injectors + API",
              "Add Redis proxy hooks (optional)",
              "Scenario runner + metrics",
              "TUI picker + status",
              "Docs + presets"
            ],
            "technical_approach": [
              "Fault injectors:",
              "Worker: delays, random failures by rate, panic/restart, partial processing.",
              "Redis: optional proxy to inject latency/drops; simulate failover (sentinel/cluster).",
              "Admin API: toggles to enable injectors with TTLs and scopes.",
              "Scenario runner:",
              "Define scenarios (duration, patterns) and run/record outcomes.",
              "Integrate with Patterned Load Generator for mixed stress.",
              "TUI:",
              "Scenario picker; live status; recovery metrics (backlog drain time, error rate).",
              "Visual markers on charts during injections.",
              "Guardrails:",
              "\u201cChaos mode\u201d banner; require typed confirmation; lock out in prod by policy."
            ],
            "code_structure": {
              "main_package": "internal/chaos-harness",
              "files": [
                "chaos-harness.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T029",
        "name": "Design Anomaly Radar Slo Budget",
        "task": {
          "id": "P4.T029",
          "feature_id": "F010",
          "title": "Design Anomaly Radar Slo Budget",
          "description": "Design task for Anomaly Radar Slo Budget",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f010-design.md",
                "docs/api/f010-openapi.yaml",
                "docs/schemas/f010-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Backlog growth, failure rate, and p95 displayed with thresholds.",
              "script": "test_p4.t029.sh"
            },
            {
              "type": "automated",
              "description": "SLO config and budget burn shown; alert when burning too fast.",
              "script": "test_p4.t029.sh"
            },
            {
              "type": "automated",
              "description": "Lightweight CPU/memory footprint.",
              "script": "test_p4.t029.sh"
            },
            {
              "type": "manual",
              "description": "Implement rolling metrics",
              "script": null
            },
            {
              "type": "manual",
              "description": "Add SLO config + budget calc",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/anomaly-radar-slo-budget.md",
              "excerpt": "A compact widget showing backlog growth, error rate, and p95 with SLO budget and burn alerts.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> SRE candy! This is Google SRE book meets terminal aesthetics. Err",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Compute rolling rates and percentiles with light sampling; thresholds for colorization.",
              "Configurable SLO target and window; simple burn rate calculation."
            ],
            "user_stories": [
              "I can see whether we\u2019re inside SLO and how fast we\u2019re burning budget."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T030",
        "name": "Implement Anomaly Radar Slo Budget",
        "task": {
          "id": "P4.T030",
          "feature_id": "F010",
          "title": "Implement Anomaly Radar Slo Budget",
          "description": "Implement task for Anomaly Radar Slo Budget",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Backlog growth, failure rate, and p95 displayed with thresholds.",
                "SLO config and budget burn shown; alert when burning too fast.",
                "Lightweight CPU/memory footprint."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/anomaly-radar-slo-budget/",
                "internal/anomaly-radar-slo-budget/*_test.go",
                "docs/api/anomaly-radar-slo-budget.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Backlog growth, failure rate, and p95 displayed with thresholds.",
              "script": "test_p4.t030.sh"
            },
            {
              "type": "automated",
              "description": "SLO config and budget burn shown; alert when burning too fast.",
              "script": "test_p4.t030.sh"
            },
            {
              "type": "automated",
              "description": "Lightweight CPU/memory footprint.",
              "script": "test_p4.t030.sh"
            },
            {
              "type": "manual",
              "description": "Implement rolling metrics",
              "script": null
            },
            {
              "type": "manual",
              "description": "Add SLO config + budget calc",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/anomaly-radar-slo-budget.md",
              "excerpt": "A compact widget showing backlog growth, error rate, and p95 with SLO budget and burn alerts.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> SRE candy! This is Google SRE book meets terminal aesthetics. Err",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Implement rolling metrics",
              "Add SLO config + budget calc",
              "Integrate widget + thresholds",
              "Document usage and tuning"
            ],
            "technical_approach": [
              "Compute rolling rates and percentiles with light sampling; thresholds for colorization.",
              "Configurable SLO target and window; simple burn rate calculation."
            ],
            "code_structure": {
              "main_package": "internal/anomaly-radar-slo-budget",
              "files": [
                "anomaly-radar-slo-budget.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T031",
        "name": "Design Automatic Capacity Planning",
        "task": {
          "id": "P4.T031",
          "feature_id": "F011",
          "title": "Design Automatic Capacity Planning",
          "description": "Design task for Automatic Capacity Planning",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f011-design.md",
                "docs/api/f011-openapi.yaml",
                "docs/schemas/f011-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Planner computes recommended replicas from \u03bb and service times under a chosen SLO.",
              "script": "test_p4.t031.sh"
            },
            {
              "type": "automated",
              "description": "Cool\u2011down and cap logic avoids oscillation.",
              "script": "test_p4.t031.sh"
            },
            {
              "type": "automated",
              "description": "TUI previews impact and supports manual apply.",
              "script": "test_p4.t031.sh"
            },
            {
              "type": "manual",
              "description": "Compute \u03bb and service stats by queue",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement planner + safety logic",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/automatic-capacity-planning.md",
              "excerpt": "Predict and set recommended worker counts to meet SLOs based on historical arrival/service rates. Generate actionable plans (or auto\u2011apply via Operator) with safety bands, cool\u2011downs, and what\u2011if simu",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Inputs:",
              "Arrival rate \u03bb(t) from enqueue metrics; service time distribution for jobs (mean, p95); current concurrency and utilization.",
              "SLO targets (p95 latency, max backlog, drain time after burst).",
              "Model:",
              "Use queueing approximations (M/M/c or M/G/c) to estimate needed concurrency `c` for target SLO.",
              "Blend with recent forecasts (EWMA/Holt\u2011Winters) to project \u03bb over next 30\u2013120 minutes.",
              "Add safety margin (e.g., 10\u201320%) and apply min/max caps.",
              "Planner:",
              "Produce a time\u2011segmented plan: desired replicas per WorkerPool per window.",
              "Add cool\u2011downs and step size limits to prevent thrash; roll forward only when confidence > threshold.",
              "Application:",
              "Manual mode: show plan in TUI with \u201cApply\u201d button.",
              "Auto mode: write desired replicas via Kubernetes Operator or local scaler.",
              "TUI:",
              "Planner panel with \u201cwhat\u2011if\u201d sliders (SLO, margin) and preview overlays on charts.",
              "Show expected backlog/latency under the proposed plan."
            ],
            "user_stories": [
              "I can see and apply a capacity plan that meets a p95 latency SLO.",
              "I can enable auto\u2011apply with caps and cooldowns."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T032",
        "name": "Implement Automatic Capacity Planning",
        "task": {
          "id": "P4.T032",
          "feature_id": "F011",
          "title": "Implement Automatic Capacity Planning",
          "description": "Implement task for Automatic Capacity Planning",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Planner computes recommended replicas from \u03bb and service times under a chosen SLO.",
                "Cool\u2011down and cap logic avoids oscillation.",
                "TUI previews impact and supports manual apply."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/automatic-capacity-planning/",
                "internal/automatic-capacity-planning/*_test.go",
                "docs/api/automatic-capacity-planning.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Planner computes recommended replicas from \u03bb and service times under a chosen SLO.",
              "script": "test_p4.t032.sh"
            },
            {
              "type": "automated",
              "description": "Cool\u2011down and cap logic avoids oscillation.",
              "script": "test_p4.t032.sh"
            },
            {
              "type": "automated",
              "description": "TUI previews impact and supports manual apply.",
              "script": "test_p4.t032.sh"
            },
            {
              "type": "manual",
              "description": "Compute \u03bb and service stats by queue",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement planner + safety logic",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/automatic-capacity-planning.md",
              "excerpt": "Predict and set recommended worker counts to meet SLOs based on historical arrival/service rates. Generate actionable plans (or auto\u2011apply via Operator) with safety bands, cool\u2011downs, and what\u2011if simu",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Compute \u03bb and service stats by queue",
              "Implement planner + safety logic",
              "TUI planner UI + overlays",
              "Operator integration for apply",
              "Docs + runbooks"
            ],
            "technical_approach": [
              "Inputs:",
              "Arrival rate \u03bb(t) from enqueue metrics; service time distribution for jobs (mean, p95); current concurrency and utilization.",
              "SLO targets (p95 latency, max backlog, drain time after burst).",
              "Model:",
              "Use queueing approximations (M/M/c or M/G/c) to estimate needed concurrency `c` for target SLO.",
              "Blend with recent forecasts (EWMA/Holt\u2011Winters) to project \u03bb over next 30\u2013120 minutes.",
              "Add safety margin (e.g., 10\u201320%) and apply min/max caps.",
              "Planner:",
              "Produce a time\u2011segmented plan: desired replicas per WorkerPool per window.",
              "Add cool\u2011downs and step size limits to prevent thrash; roll forward only when confidence > threshold.",
              "Application:",
              "Manual mode: show plan in TUI with \u201cApply\u201d button.",
              "Auto mode: write desired replicas via Kubernetes Operator or local scaler.",
              "TUI:",
              "Planner panel with \u201cwhat\u2011if\u201d sliders (SLO, margin) and preview overlays on charts.",
              "Show expected backlog/latency under the proposed plan."
            ],
            "code_structure": {
              "main_package": "internal/automatic-capacity-planning",
              "files": [
                "automatic-capacity-planning.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T033",
        "name": "Design Kubernetes Operator",
        "task": {
          "id": "P4.T033",
          "feature_id": "F012",
          "title": "Design Kubernetes Operator",
          "description": "Design task for Kubernetes Operator",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f012-design.md",
                "docs/api/f012-openapi.yaml",
                "docs/schemas/f012-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "CRDs with schemas and validation webhooks.",
              "script": "test_p4.t033.sh"
            },
            {
              "type": "automated",
              "description": "Reconciler manages Deployments and scales by backlog/SLO.",
              "script": "test_p4.t033.sh"
            },
            {
              "type": "automated",
              "description": "Rolling updates drain before restart.",
              "script": "test_p4.t033.sh"
            },
            {
              "type": "manual",
              "description": "Define CRDs + validation webhooks",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement reconcilers (Queue, WorkerPool)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/kubernetes-operator.md",
              "excerpt": "Ship a Kubernetes Operator with CRDs to declaratively manage queues and workers. Reconcile desired state (workers, rate limits, DLQ policies) from YAML, autoscale by backlog/SLA targets, and support s",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "CRDs:",
              "`Queue`: name, priorities, rate limits, DLQ config, retention.",
              "`WorkerPool`: image, version, env, resources, concurrency, max in\u2011flight, drain policy, min/max replicas.",
              "`Policy`: global knobs (circuit breaker thresholds, retry/backoff defaults).",
              "Reconciliation:",
              "Manage Deployments/StatefulSets for workers; inject config/secret mounts.",
              "Observe metrics (backlog length, p95 latency) and scale `WorkerPool` via HPA\u2011like logic.",
              "Orchestrate rolling updates with drain/ready hooks via Admin API.",
              "Safety & RBAC:",
              "Namespace\u2011scoped by default; cluster\u2011scoped optional.",
              "Webhooks: CRD validation (limits, reserved names), defaulting, and drift detection.",
              "Finalizers to drain on delete; prevent orphaned DLQs.",
              "Observability:",
              "Conditions per resource; events; Prometheus metrics (reconcile durations, errors).",
              "Tooling:",
              "Kustomize bases for common setups; examples repo."
            ],
            "user_stories": [
              "I can declare a `WorkerPool` and see it reconcile with autoscaling.",
              "I can update a `Queue` rate limit and see changes propagate safely."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T034",
        "name": "Implement Kubernetes Operator",
        "task": {
          "id": "P4.T034",
          "feature_id": "F012",
          "title": "Implement Kubernetes Operator",
          "description": "Implement task for Kubernetes Operator",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "CRDs with schemas and validation webhooks.",
                "Reconciler manages Deployments and scales by backlog/SLO.",
                "Rolling updates drain before restart."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/kubernetes-operator/",
                "internal/kubernetes-operator/*_test.go",
                "docs/api/kubernetes-operator.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "CRDs with schemas and validation webhooks.",
              "script": "test_p4.t034.sh"
            },
            {
              "type": "automated",
              "description": "Reconciler manages Deployments and scales by backlog/SLO.",
              "script": "test_p4.t034.sh"
            },
            {
              "type": "automated",
              "description": "Rolling updates drain before restart.",
              "script": "test_p4.t034.sh"
            },
            {
              "type": "manual",
              "description": "Define CRDs + validation webhooks",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement reconcilers (Queue, WorkerPool)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/kubernetes-operator.md",
              "excerpt": "Ship a Kubernetes Operator with CRDs to declaratively manage queues and workers. Reconcile desired state (workers, rate limits, DLQ policies) from YAML, autoscale by backlog/SLA targets, and support s",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define CRDs + validation webhooks",
              "Implement reconcilers (Queue, WorkerPool)",
              "Autoscaling logic (backlog/SLO)",
              "Rolling update hooks (drain/ready)",
              "Examples + CI e2e"
            ],
            "technical_approach": [
              "CRDs:",
              "`Queue`: name, priorities, rate limits, DLQ config, retention.",
              "`WorkerPool`: image, version, env, resources, concurrency, max in\u2011flight, drain policy, min/max replicas.",
              "`Policy`: global knobs (circuit breaker thresholds, retry/backoff defaults).",
              "Reconciliation:",
              "Manage Deployments/StatefulSets for workers; inject config/secret mounts.",
              "Observe metrics (backlog length, p95 latency) and scale `WorkerPool` via HPA\u2011like logic.",
              "Orchestrate rolling updates with drain/ready hooks via Admin API.",
              "Safety & RBAC:",
              "Namespace\u2011scoped by default; cluster\u2011scoped optional.",
              "Webhooks: CRD validation (limits, reserved names), defaulting, and drift detection.",
              "Finalizers to drain on delete; prevent orphaned DLQs.",
              "Observability:",
              "Conditions per resource; events; Prometheus metrics (reconcile durations, errors).",
              "Tooling:",
              "Kustomize bases for common setups; examples repo."
            ],
            "code_structure": {
              "main_package": "internal/kubernetes-operator",
              "files": [
                "kubernetes-operator.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T035",
        "name": "Design Canary Deployments",
        "task": {
          "id": "P3.T035",
          "feature_id": "F013",
          "title": "Design Canary Deployments",
          "description": "Design task for Canary Deployments",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f013-design.md",
                "docs/api/f013-openapi.yaml",
                "docs/schemas/f013-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Version\u2011aware routing with configurable percentages.",
              "script": "test_p3.t035.sh"
            },
            {
              "type": "automated",
              "description": "Side\u2011by\u2011side SLO metrics with alerts on regression.",
              "script": "test_p3.t035.sh"
            },
            {
              "type": "automated",
              "description": "Promote/rollback flows with confirmations and drain behavior.",
              "script": "test_p3.t035.sh"
            },
            {
              "type": "manual",
              "description": "Worker version/label plumbing",
              "script": null
            },
            {
              "type": "manual",
              "description": "Routing implementation (split queues or groups)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/canary-deployments.md",
              "excerpt": "Safely roll out new worker versions by routing a configurable percentage of jobs to canaries, compare key SLOs, and promote or roll back quickly. Support sticky routing and per\u2011queue/tenant canaries.\n",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Versioning & labels:",
              "Workers advertise `version` and `lane` (stable/canary) via heartbeat/registration.",
              "Routing strategies:",
              "Split queues: enqueue sampler routes N% to `queue@canary` (separate key); canary workers only consume `@canary`.",
              "Stream groups (if using Streams): distinct consumer group per version with weighted claim.",
              "Hash\u2011based sticky: route by job ID hash for consistency during a canary window.",
              "Control plane:",
              "Admin API to configure percentages per queue/tenant and window duration.",
              "Automatic promotion on green metrics or manual confirmation.",
              "Fast rollback sets canary to 0% and drains remaining.",
              "Observability:",
              "Compare p50/p95 latency, error/DLQ rates, resource usage per version.",
              "TUI panel with sparkline deltas and a one\u2011click promote/rollback (with confirm).",
              "Safety:",
              "Guard critical queues with max canary %; block incompatible schema changes without a feature flag."
            ],
            "user_stories": [
              "I can set a 10% canary for `payments` and watch metrics before promoting.",
              "I can roll back immediately with a single action when errors spike."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T036",
        "name": "Implement Canary Deployments",
        "task": {
          "id": "P3.T036",
          "feature_id": "F013",
          "title": "Implement Canary Deployments",
          "description": "Implement task for Canary Deployments",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Version\u2011aware routing with configurable percentages.",
                "Side\u2011by\u2011side SLO metrics with alerts on regression.",
                "Promote/rollback flows with confirmations and drain behavior."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/canary-deployments/",
                "internal/canary-deployments/*_test.go",
                "docs/api/canary-deployments.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Version\u2011aware routing with configurable percentages.",
              "script": "test_p3.t036.sh"
            },
            {
              "type": "automated",
              "description": "Side\u2011by\u2011side SLO metrics with alerts on regression.",
              "script": "test_p3.t036.sh"
            },
            {
              "type": "automated",
              "description": "Promote/rollback flows with confirmations and drain behavior.",
              "script": "test_p3.t036.sh"
            },
            {
              "type": "manual",
              "description": "Worker version/label plumbing",
              "script": null
            },
            {
              "type": "manual",
              "description": "Routing implementation (split queues or groups)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/canary-deployments.md",
              "excerpt": "Safely roll out new worker versions by routing a configurable percentage of jobs to canaries, compare key SLOs, and promote or roll back quickly. Support sticky routing and per\u2011queue/tenant canaries.\n",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Worker version/label plumbing",
              "Routing implementation (split queues or groups)",
              "Admin API for percentages + windows",
              "TUI canary panel + controls",
              "Docs + runbooks"
            ],
            "technical_approach": [
              "Versioning & labels:",
              "Workers advertise `version` and `lane` (stable/canary) via heartbeat/registration.",
              "Routing strategies:",
              "Split queues: enqueue sampler routes N% to `queue@canary` (separate key); canary workers only consume `@canary`.",
              "Stream groups (if using Streams): distinct consumer group per version with weighted claim.",
              "Hash\u2011based sticky: route by job ID hash for consistency during a canary window.",
              "Control plane:",
              "Admin API to configure percentages per queue/tenant and window duration.",
              "Automatic promotion on green metrics or manual confirmation.",
              "Fast rollback sets canary to 0% and drains remaining.",
              "Observability:",
              "Compare p50/p95 latency, error/DLQ rates, resource usage per version.",
              "TUI panel with sparkline deltas and a one\u2011click promote/rollback (with confirm).",
              "Safety:",
              "Guard critical queues with max canary %; block incompatible schema changes without a feature flag."
            ],
            "code_structure": {
              "main_package": "internal/canary-deployments",
              "files": [
                "canary-deployments.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T037",
        "name": "Design Event Hooks",
        "task": {
          "id": "P2.T037",
          "feature_id": "F014",
          "title": "Design Event Hooks",
          "description": "Design task for Event Hooks",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f014-design.md",
                "docs/api/f014-openapi.yaml",
                "docs/schemas/f014-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Subscriptions with filters and secrets.",
              "script": "test_p2.t037.sh"
            },
            {
              "type": "automated",
              "description": "Delivery with retries, backoff, and DLH.",
              "script": "test_p2.t037.sh"
            },
            {
              "type": "automated",
              "description": "Test and replay supported via Admin API and TUI.",
              "script": "test_p2.t037.sh"
            },
            {
              "type": "manual",
              "description": "Define event schema + bus",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement webhook + NATS transports",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/event-hooks.md",
              "excerpt": "Emit events for job lifecycle changes (enqueued, started, succeeded, failed, DLQ) to external systems via webhooks or NATS. Signed payloads, backoff retries, and per\u2011queue filters provide safe, flexib",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Event bus:",
              "Internal dispatcher with typed events and subscriber backends.",
              "Events: job_enqueued, job_started, job_succeeded, job_failed, job_dlq, job_retried.",
              "Transports:",
              "Webhooks: POST JSON with HMAC signature, per\u2011subscription secret.",
              "NATS (optional): publish to subjects by event type and queue.",
              "Delivery semantics:",
              "At\u2011least\u2011once with exponential backoff; max attempts; dead\u2011letter for hooks.",
              "Idempotency key in headers; timestamp; correlation/trace IDs when available.",
              "Config:",
              "Subscriptions: matchers (queue, priority, result), endpoint/subject, headers, secret, rate cap.",
              "Health: last delivery status, retry counts, moving window success rate.",
              "Admin API:",
              "CRUD subscriptions, test delivery, list DLH (dead\u2011letter hooks) with replay.",
              "TUI:",
              "Minimal management panel: list subscriptions and status; trigger test; replay failed.",
              "Security: HMAC signing; optional mTLS; redact sensitive payload fields by pattern."
            ],
            "user_stories": [
              "I can subscribe a webhook to `job_failed` for queue `payments` with a secret and receive signed payloads.",
              "I can see delivery success rate and replay failures."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T038",
        "name": "Implement Event Hooks",
        "task": {
          "id": "P2.T038",
          "feature_id": "F014",
          "title": "Implement Event Hooks",
          "description": "Implement task for Event Hooks",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Subscriptions with filters and secrets.",
                "Delivery with retries, backoff, and DLH.",
                "Test and replay supported via Admin API and TUI."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/event-hooks/",
                "internal/event-hooks/*_test.go",
                "docs/api/event-hooks.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Subscriptions with filters and secrets.",
              "script": "test_p2.t038.sh"
            },
            {
              "type": "automated",
              "description": "Delivery with retries, backoff, and DLH.",
              "script": "test_p2.t038.sh"
            },
            {
              "type": "automated",
              "description": "Test and replay supported via Admin API and TUI.",
              "script": "test_p2.t038.sh"
            },
            {
              "type": "manual",
              "description": "Define event schema + bus",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement webhook + NATS transports",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/event-hooks.md",
              "excerpt": "Emit events for job lifecycle changes (enqueued, started, succeeded, failed, DLQ) to external systems via webhooks or NATS. Signed payloads, backoff retries, and per\u2011queue filters provide safe, flexib",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define event schema + bus",
              "Implement webhook + NATS transports",
              "Retry/backoff + DLH storage",
              "Admin API CRUD + test/replay",
              "TUI management panel",
              "Docs + samples"
            ],
            "technical_approach": [
              "Event bus:",
              "Internal dispatcher with typed events and subscriber backends.",
              "Events: job_enqueued, job_started, job_succeeded, job_failed, job_dlq, job_retried.",
              "Transports:",
              "Webhooks: POST JSON with HMAC signature, per\u2011subscription secret.",
              "NATS (optional): publish to subjects by event type and queue.",
              "Delivery semantics:",
              "At\u2011least\u2011once with exponential backoff; max attempts; dead\u2011letter for hooks.",
              "Idempotency key in headers; timestamp; correlation/trace IDs when available.",
              "Config:",
              "Subscriptions: matchers (queue, priority, result), endpoint/subject, headers, secret, rate cap.",
              "Health: last delivery status, retry counts, moving window success rate.",
              "Admin API:",
              "CRUD subscriptions, test delivery, list DLH (dead\u2011letter hooks) with replay.",
              "TUI:",
              "Minimal management panel: list subscriptions and status; trigger test; replay failed.",
              "Security: HMAC signing; optional mTLS; redact sensitive payload fields by pattern."
            ],
            "code_structure": {
              "main_package": "internal/event-hooks",
              "files": [
                "event-hooks.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T039",
        "name": "Test Event Hooks",
        "task": {
          "id": "P2.T039",
          "feature_id": "F014",
          "title": "Test Event Hooks",
          "description": "Test task for Event Hooks",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Subscriptions with filters and secrets.",
              "script": "test_p2.t039.sh"
            },
            {
              "type": "automated",
              "description": "Delivery with retries, backoff, and DLH.",
              "script": "test_p2.t039.sh"
            },
            {
              "type": "automated",
              "description": "Test and replay supported via Admin API and TUI.",
              "script": "test_p2.t039.sh"
            },
            {
              "type": "manual",
              "description": "Define event schema + bus",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement webhook + NATS transports",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/event-hooks.md",
              "excerpt": "Emit events for job lifecycle changes (enqueued, started, succeeded, failed, DLQ) to external systems via webhooks or NATS. Signed payloads, backoff retries, and per\u2011queue filters provide safe, flexib",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: signature generation/verification; backoff schedule; filter matching."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: webhook endpoint harness; NATS subject contract; DLH replay."
                ],
                "priority": "high"
              },
              {
                "type": "security",
                "tests": [
                  "Security: signature tamper tests; redaction validation."
                ],
                "priority": "medium"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T040",
        "name": "Design Smart Payload Deduplication",
        "task": {
          "id": "P3.T040",
          "feature_id": "F015",
          "title": "Design Smart Payload Deduplication",
          "description": "Design task for Smart Payload Deduplication",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f015-design.md",
                "docs/api/f015-openapi.yaml",
                "docs/schemas/f015-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": ">50% memory savings on typical workloads",
              "script": "test_p3.t040.sh"
            },
            {
              "type": "automated",
              "description": "<10ms overhead for dedup/reconstruction",
              "script": "test_p3.t040.sh"
            },
            {
              "type": "automated",
              "description": "Zero data loss with checksums and verification",
              "script": "test_p3.t040.sh"
            },
            {
              "type": "manual",
              "description": "Automatic garbage collection of unreferenced chunks",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement content-based chunking",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/smart-payload-deduplication.md",
              "excerpt": "Intelligent deduplication system that detects similar job payloads and stores them once, dramatically reducing Redis memory usage. Uses content-addressable storage with smart chunking to find commonal",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Deduplication Strategy:",
              "Content-based chunking using rolling hash (Rabin fingerprinting)",
              "Store chunks in content-addressable store (CAS)",
              "Job payloads become lists of chunk references",
              "Reference counting for garbage collection",
              "Smart Detection:",
              "Fuzzy matching for near-duplicates (similarity threshold)",
              "Template detection: identify common structures with variable parts",
              "Compression: zstd with dictionary learned from payload corpus",
              "Storage Architecture:",
              "Chunk store: `dedup:chunk:{hash}` \u2192 compressed data",
              "Reference index: `dedup:refs:{job_id}` \u2192 chunk list",
              "Stats tracking: dedup ratio, savings, popular chunks",
              "Integration Points:",
              "Producer: dedupe at enqueue time",
              "Worker: reconstruct at dequeue",
              "Admin: dedup stats and tuning",
              "Transparent to application code",
              "Safety:",
              "Verify chunk integrity with checksums",
              "Atomic reference counting",
              "Gradual rollout with feature flags",
              "Fallback to non-deduped storage"
            ],
            "user_stories": [
              "I can see 70% memory reduction for repetitive job workloads",
              "deduplication is completely transparent to my job processing code",
              "I can monitor dedup effectiveness and tune parameters"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T041",
        "name": "Implement Smart Payload Deduplication",
        "task": {
          "id": "P3.T041",
          "feature_id": "F015",
          "title": "Implement Smart Payload Deduplication",
          "description": "Implement task for Smart Payload Deduplication",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                ">50% memory savings on typical workloads",
                "<10ms overhead for dedup/reconstruction",
                "Zero data loss with checksums and verification"
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/smart-payload-deduplication/",
                "internal/smart-payload-deduplication/*_test.go",
                "docs/api/smart-payload-deduplication.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": ">50% memory savings on typical workloads",
              "script": "test_p3.t041.sh"
            },
            {
              "type": "automated",
              "description": "<10ms overhead for dedup/reconstruction",
              "script": "test_p3.t041.sh"
            },
            {
              "type": "automated",
              "description": "Zero data loss with checksums and verification",
              "script": "test_p3.t041.sh"
            },
            {
              "type": "manual",
              "description": "Automatic garbage collection of unreferenced chunks",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement content-based chunking",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/smart-payload-deduplication.md",
              "excerpt": "Intelligent deduplication system that detects similar job payloads and stores them once, dramatically reducing Redis memory usage. Uses content-addressable storage with smart chunking to find commonal",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Implement content-based chunking",
              "Build chunk store with CAS",
              "Add reference counting and GC",
              "Integrate with producer/worker",
              "Create admin stats dashboard",
              "Performance tuning",
              "Migration tooling"
            ],
            "technical_approach": [
              "Deduplication Strategy:",
              "Content-based chunking using rolling hash (Rabin fingerprinting)",
              "Store chunks in content-addressable store (CAS)",
              "Job payloads become lists of chunk references",
              "Reference counting for garbage collection",
              "Smart Detection:",
              "Fuzzy matching for near-duplicates (similarity threshold)",
              "Template detection: identify common structures with variable parts",
              "Compression: zstd with dictionary learned from payload corpus",
              "Storage Architecture:",
              "Chunk store: `dedup:chunk:{hash}` \u2192 compressed data",
              "Reference index: `dedup:refs:{job_id}` \u2192 chunk list",
              "Stats tracking: dedup ratio, savings, popular chunks",
              "Integration Points:",
              "Producer: dedupe at enqueue time",
              "Worker: reconstruct at dequeue",
              "Admin: dedup stats and tuning",
              "Transparent to application code",
              "Safety:",
              "Verify chunk integrity with checksums",
              "Atomic reference counting",
              "Gradual rollout with feature flags",
              "Fallback to non-deduped storage"
            ],
            "code_structure": {
              "main_package": "internal/smart-payload-deduplication",
              "files": [
                "smart-payload-deduplication.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T042",
        "name": "Design Job Budgeting",
        "task": {
          "id": "P3.T042",
          "feature_id": "F016",
          "title": "Design Job Budgeting",
          "description": "Design task for Job Budgeting",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f016-design.md",
                "docs/api/f016-openapi.yaml",
                "docs/schemas/f016-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Cost calculation with pluggable weights; daily aggregates.",
              "script": "test_p3.t042.sh"
            },
            {
              "type": "automated",
              "description": "Budgets with warning/enforcement thresholds and notifications.",
              "script": "test_p3.t042.sh"
            },
            {
              "type": "automated",
              "description": "TUI shows spend, forecast, and top drivers.",
              "script": "test_p3.t042.sh"
            },
            {
              "type": "manual",
              "description": "Define cost model + calibration suite",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement capture and aggregation",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/job-budgeting.md",
              "excerpt": "Track and allocate cost per job/tenant using measured resource usage and a simple cost model. Define monthly budgets, show spend vs. budget, forecast burn, and apply optional enforcement (soft warning",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Cost model:",
              "Components: processing time (CPU), memory footprint proxy, payload size, Redis ops, egress hints.",
              "Assign weights/cost rates; calibrate with benchmarks and environment multipliers.",
              "Data capture:",
              "Worker reports per\u2011job timings and optional resource proxies; producer reports payload size.",
              "Aggregate by tenant/queue/day; store in a compact table (ClickHouse optional).",
              "Budgets & policies:",
              "Define budgets per tenant/queue; thresholds for warning/limit.",
              "Enforcement ladder: warn producers \u2192 suggest backpressure \u2192 throttle low\u2011priority work; never drop without explicit policy.",
              "Integration:",
              "Advanced Rate Limiting uses remaining budget as an input for weights.",
              "Event Hooks for budget threshold notifications.",
              "TUI:",
              "Budgets panel: current spend, forecast to month\u2011end, top cost drivers, and recent spikes; drill into job samples."
            ],
            "user_stories": [
              "I can set budgets and see spend by tenant and queue.",
              "I receive early warnings and suggestions if I'm overspending."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T043",
        "name": "Implement Job Budgeting",
        "task": {
          "id": "P3.T043",
          "feature_id": "F016",
          "title": "Implement Job Budgeting",
          "description": "Implement task for Job Budgeting",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Cost calculation with pluggable weights; daily aggregates.",
                "Budgets with warning/enforcement thresholds and notifications.",
                "TUI shows spend, forecast, and top drivers."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/job-budgeting/",
                "internal/job-budgeting/*_test.go",
                "docs/api/job-budgeting.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Cost calculation with pluggable weights; daily aggregates.",
              "script": "test_p3.t043.sh"
            },
            {
              "type": "automated",
              "description": "Budgets with warning/enforcement thresholds and notifications.",
              "script": "test_p3.t043.sh"
            },
            {
              "type": "automated",
              "description": "TUI shows spend, forecast, and top drivers.",
              "script": "test_p3.t043.sh"
            },
            {
              "type": "manual",
              "description": "Define cost model + calibration suite",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement capture and aggregation",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/job-budgeting.md",
              "excerpt": "Track and allocate cost per job/tenant using measured resource usage and a simple cost model. Define monthly budgets, show spend vs. budget, forecast burn, and apply optional enforcement (soft warning",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define cost model + calibration suite",
              "Implement capture and aggregation",
              "Budgets + enforcement hooks",
              "TUI budgets panel + drilldown",
              "Docs + operator guidance"
            ],
            "technical_approach": [
              "Cost model:",
              "Components: processing time (CPU), memory footprint proxy, payload size, Redis ops, egress hints.",
              "Assign weights/cost rates; calibrate with benchmarks and environment multipliers.",
              "Data capture:",
              "Worker reports per\u2011job timings and optional resource proxies; producer reports payload size.",
              "Aggregate by tenant/queue/day; store in a compact table (ClickHouse optional).",
              "Budgets & policies:",
              "Define budgets per tenant/queue; thresholds for warning/limit.",
              "Enforcement ladder: warn producers \u2192 suggest backpressure \u2192 throttle low\u2011priority work; never drop without explicit policy.",
              "Integration:",
              "Advanced Rate Limiting uses remaining budget as an input for weights.",
              "Event Hooks for budget threshold notifications.",
              "TUI:",
              "Budgets panel: current spend, forecast to month\u2011end, top cost drivers, and recent spikes; drill into job samples."
            ],
            "code_structure": {
              "main_package": "internal/job-budgeting",
              "files": [
                "job-budgeting.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T044",
        "name": "Design Job Genealogy Navigator",
        "task": {
          "id": "P4.T044",
          "feature_id": "F017",
          "title": "Design Job Genealogy Navigator",
          "description": "Design task for Job Genealogy Navigator",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f017-design.md",
                "docs/api/f017-openapi.yaml",
                "docs/schemas/f017-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Complete genealogy captured automatically",
              "script": "test_p4.t044.sh"
            },
            {
              "type": "automated",
              "description": "Tree renders smoothly for 100+ node families",
              "script": "test_p4.t044.sh"
            },
            {
              "type": "automated",
              "description": "Navigation responsive with <50ms updates",
              "script": "test_p4.t044.sh"
            },
            {
              "type": "manual",
              "description": "Relationship data automatically pruned after TTL",
              "script": null
            },
            {
              "type": "manual",
              "description": "Design relationship schema",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/job-genealogy-navigator.md",
              "excerpt": "Interactive visualization of job family trees showing parent-child relationships, retry chains, spawned subjobs, and failure cascades. Navigate complex job genealogies in the TUI to understand causali",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Relationship Tracking:",
              "Capture parent_id, spawn_reason, relationship_type in job metadata",
              "Relationship types: retry, spawn, fork, callback, compensation",
              "Bidirectional indexes: parent\u2192children, child\u2192ancestors",
              "Store in Redis sorted sets for efficient traversal",
              "Graph Operations:",
              "Build family tree from any job (ancestors + descendants)",
              "Find common ancestors between failed jobs",
              "Calculate impact radius (all affected descendants)",
              "Detect cycles and anomalies",
              "TUI Visualization:",
              "ASCII art tree with box-drawing characters",
              "Collapsible/expandable nodes",
              "Color coding: green (success), red (failed), yellow (processing), gray (pending)",
              "Navigation: arrow keys to traverse, enter to inspect, 'f' to focus subtree",
              "Multiple layout algorithms: top-down tree, left-right timeline, radial",
              "Analysis Features:",
              "\"Blame\" mode: trace failure to root cause",
              "\"Impact\" mode: show all affected descendants",
              "Pattern detection: identify recurring failure genealogies",
              "Time-lapse: animate tree growth over time",
              "Integration:",
              "Auto-capture relationships during enqueue/retry/spawn",
              "Link with Time Travel Debugger for replay",
              "Export as DOT/Mermaid for external visualization"
            ],
            "user_stories": [
              "I can see the complete family tree of any job",
              "I can trace cascading failures to their root cause",
              "I can identify patterns in job relationships over time"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T045",
        "name": "Implement Job Genealogy Navigator",
        "task": {
          "id": "P4.T045",
          "feature_id": "F017",
          "title": "Implement Job Genealogy Navigator",
          "description": "Implement task for Job Genealogy Navigator",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Complete genealogy captured automatically",
                "Tree renders smoothly for 100+ node families",
                "Navigation responsive with <50ms updates"
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/job-genealogy-navigator/",
                "internal/job-genealogy-navigator/*_test.go",
                "docs/api/job-genealogy-navigator.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Complete genealogy captured automatically",
              "script": "test_p4.t045.sh"
            },
            {
              "type": "automated",
              "description": "Tree renders smoothly for 100+ node families",
              "script": "test_p4.t045.sh"
            },
            {
              "type": "automated",
              "description": "Navigation responsive with <50ms updates",
              "script": "test_p4.t045.sh"
            },
            {
              "type": "manual",
              "description": "Relationship data automatically pruned after TTL",
              "script": null
            },
            {
              "type": "manual",
              "description": "Design relationship schema",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/job-genealogy-navigator.md",
              "excerpt": "Interactive visualization of job family trees showing parent-child relationships, retry chains, spawned subjobs, and failure cascades. Navigate complex job genealogies in the TUI to understand causali",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Design relationship schema",
              "Implement relationship capture",
              "Build graph traversal algorithms",
              "Create ASCII tree renderer",
              "Add navigation controls",
              "Implement analysis modes",
              "Performance optimization"
            ],
            "technical_approach": [
              "Relationship Tracking:",
              "Capture parent_id, spawn_reason, relationship_type in job metadata",
              "Relationship types: retry, spawn, fork, callback, compensation",
              "Bidirectional indexes: parent\u2192children, child\u2192ancestors",
              "Store in Redis sorted sets for efficient traversal",
              "Graph Operations:",
              "Build family tree from any job (ancestors + descendants)",
              "Find common ancestors between failed jobs",
              "Calculate impact radius (all affected descendants)",
              "Detect cycles and anomalies",
              "TUI Visualization:",
              "ASCII art tree with box-drawing characters",
              "Collapsible/expandable nodes",
              "Color coding: green (success), red (failed), yellow (processing), gray (pending)",
              "Navigation: arrow keys to traverse, enter to inspect, 'f' to focus subtree",
              "Multiple layout algorithms: top-down tree, left-right timeline, radial",
              "Analysis Features:",
              "\"Blame\" mode: trace failure to root cause",
              "\"Impact\" mode: show all affected descendants",
              "Pattern detection: identify recurring failure genealogies",
              "Time-lapse: animate tree growth over time",
              "Integration:",
              "Auto-capture relationships during enqueue/retry/spawn",
              "Link with Time Travel Debugger for replay",
              "Export as DOT/Mermaid for external visualization"
            ],
            "code_structure": {
              "main_package": "internal/job-genealogy-navigator",
              "files": [
                "job-genealogy-navigator.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T046",
        "name": "Design Long Term Archives",
        "task": {
          "id": "P3.T046",
          "feature_id": "F018",
          "title": "Design Long Term Archives",
          "description": "Design task for Long Term Archives",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f018-design.md",
                "docs/api/f018-openapi.yaml",
                "docs/schemas/f018-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Exporter writes to ClickHouse/S3 with retries and idempotency.",
              "script": "test_p3.t046.sh"
            },
            {
              "type": "automated",
              "description": "Schema versioning with backward compatibility.",
              "script": "test_p3.t046.sh"
            },
            {
              "type": "automated",
              "description": "Configurable retention in Redis and archive.",
              "script": "test_p3.t046.sh"
            },
            {
              "type": "manual",
              "description": "Define archive schema + sampling",
              "script": null
            },
            {
              "type": "manual",
              "description": "Build exporter (ClickHouse + S3/Parquet)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/long-term-archives.md",
              "excerpt": "Stream completed jobs and key metadata to long\u2011term storage (ClickHouse or S3/Parquet) with retention controls. Provide fast querying for forensics and reporting while keeping Redis slim.\n\n> [!note]- ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Export path:",
              "Producer: append to a Completed stream (list/stream) on success/failure; optional sampling.",
              "Exporter service: batch reads and writes to ClickHouse (insert) or S3 (Parquet files) with schema evolution.",
              "Schema:",
              "Core: job_id, queue, priority, timestamps (enqueue/start/end), outcome, retries, worker_id, size, trace_id.",
              "Payload handling: optional redacted payload snapshot or hashes.",
              "Retention:",
              "TTL in Redis; archive window controls; GDPR delete hooks to remove payload snapshots.",
              "TUI:",
              "Link to sample queries and recent export status; not a full query UI.",
              "Observability:",
              "Lag metrics, batch sizes, write errors; alerts when exporters fall behind."
            ],
            "user_stories": [
              "I can query last 90 days of completed jobs by queue and outcome.",
              "I can verify Redis stays within retention while exports keep up."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T047",
        "name": "Implement Long Term Archives",
        "task": {
          "id": "P3.T047",
          "feature_id": "F018",
          "title": "Implement Long Term Archives",
          "description": "Implement task for Long Term Archives",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Exporter writes to ClickHouse/S3 with retries and idempotency.",
                "Schema versioning with backward compatibility.",
                "Configurable retention in Redis and archive."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/long-term-archives/",
                "internal/long-term-archives/*_test.go",
                "docs/api/long-term-archives.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [
              "redis_schema"
            ],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Exporter writes to ClickHouse/S3 with retries and idempotency.",
              "script": "test_p3.t047.sh"
            },
            {
              "type": "automated",
              "description": "Schema versioning with backward compatibility.",
              "script": "test_p3.t047.sh"
            },
            {
              "type": "automated",
              "description": "Configurable retention in Redis and archive.",
              "script": "test_p3.t047.sh"
            },
            {
              "type": "manual",
              "description": "Define archive schema + sampling",
              "script": null
            },
            {
              "type": "manual",
              "description": "Build exporter (ClickHouse + S3/Parquet)",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/long-term-archives.md",
              "excerpt": "Stream completed jobs and key metadata to long\u2011term storage (ClickHouse or S3/Parquet) with retention controls. Provide fast querying for forensics and reporting while keeping Redis slim.\n\n> [!note]- ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define archive schema + sampling",
              "Build exporter (ClickHouse + S3/Parquet)",
              "Add retention knobs + delete hooks",
              "TUI export status panel",
              "Docs + sample queries"
            ],
            "technical_approach": [
              "Export path:",
              "Producer: append to a Completed stream (list/stream) on success/failure; optional sampling.",
              "Exporter service: batch reads and writes to ClickHouse (insert) or S3 (Parquet files) with schema evolution.",
              "Schema:",
              "Core: job_id, queue, priority, timestamps (enqueue/start/end), outcome, retries, worker_id, size, trace_id.",
              "Payload handling: optional redacted payload snapshot or hashes.",
              "Retention:",
              "TTL in Redis; archive window controls; GDPR delete hooks to remove payload snapshots.",
              "TUI:",
              "Link to sample queries and recent export status; not a full query UI.",
              "Observability:",
              "Lag metrics, batch sizes, write errors; alerts when exporters fall behind."
            ],
            "code_structure": {
              "main_package": "internal/long-term-archives",
              "files": [
                "long-term-archives.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T048",
        "name": "Design Forecasting",
        "task": {
          "id": "P4.T048",
          "feature_id": "F019",
          "title": "Design Forecasting",
          "description": "Design task for Forecasting",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f019-design.md",
                "docs/api/f019-openapi.yaml",
                "docs/schemas/f019-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Baseline forecasting on backlog/throughput with confidence bands.",
              "script": "test_p4.t048.sh"
            },
            {
              "type": "automated",
              "description": "Recommendations generated and displayed succinctly.",
              "script": "test_p4.t048.sh"
            },
            {
              "type": "automated",
              "description": "Toggleable overlays; no impact on core loop performance.",
              "script": "test_p4.t048.sh"
            },
            {
              "type": "manual",
              "description": "Implement EWMA/Holt\u2011Winters",
              "script": null
            },
            {
              "type": "manual",
              "description": "Persist short history; optional TSDB reader",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/forecasting.md",
              "excerpt": "Predict backlog, throughput, and error trends using simple time\u2011series models (moving averages, Holt\u2011Winters, optional ARIMA) to recommend scaling actions and SLO adjustments.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Data:",
              "Persist short history in\u2011memory for TUI charts and optionally to disk for longer windows.",
              "Optionally pull from metrics TSDB (Prometheus) for richer history.",
              "Models:",
              "Baseline: EWMA / Holt\u2011Winters; later ARIMA/Prophet plugins.",
              "Compute point forecasts and confidence bounds.",
              "Recommendations:",
              "Translate forecasts into human hints (e.g., \"Scale workers +2 for next 30m\").",
              "Budget burn projections for SLO widget.",
              "TUI:",
              "Overlay forecast bands on charts; show next 30\u2013120m.",
              "Small \"What's Next\" panel with recommendations."
            ],
            "user_stories": [
              "I can see forecast bands on queue charts and a plain\u2011English recommendation."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T049",
        "name": "Implement Forecasting",
        "task": {
          "id": "P4.T049",
          "feature_id": "F019",
          "title": "Implement Forecasting",
          "description": "Implement task for Forecasting",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Baseline forecasting on backlog/throughput with confidence bands.",
                "Recommendations generated and displayed succinctly.",
                "Toggleable overlays; no impact on core loop performance."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/forecasting/",
                "internal/forecasting/*_test.go",
                "docs/api/forecasting.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Baseline forecasting on backlog/throughput with confidence bands.",
              "script": "test_p4.t049.sh"
            },
            {
              "type": "automated",
              "description": "Recommendations generated and displayed succinctly.",
              "script": "test_p4.t049.sh"
            },
            {
              "type": "automated",
              "description": "Toggleable overlays; no impact on core loop performance.",
              "script": "test_p4.t049.sh"
            },
            {
              "type": "manual",
              "description": "Implement EWMA/Holt\u2011Winters",
              "script": null
            },
            {
              "type": "manual",
              "description": "Persist short history; optional TSDB reader",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/forecasting.md",
              "excerpt": "Predict backlog, throughput, and error trends using simple time\u2011series models (moving averages, Holt\u2011Winters, optional ARIMA) to recommend scaling actions and SLO adjustments.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Implement EWMA/Holt\u2011Winters",
              "Persist short history; optional TSDB reader",
              "Overlay UI + recommendations",
              "Docs + examples"
            ],
            "technical_approach": [
              "Data:",
              "Persist short history in\u2011memory for TUI charts and optionally to disk for longer windows.",
              "Optionally pull from metrics TSDB (Prometheus) for richer history.",
              "Models:",
              "Baseline: EWMA / Holt\u2011Winters; later ARIMA/Prophet plugins.",
              "Compute point forecasts and confidence bounds.",
              "Recommendations:",
              "Translate forecasts into human hints (e.g., \"Scale workers +2 for next 30m\").",
              "Budget burn projections for SLO widget.",
              "TUI:",
              "Overlay forecast bands on charts; show next 30\u2013120m.",
              "Small \"What's Next\" panel with recommendations."
            ],
            "code_structure": {
              "main_package": "internal/forecasting",
              "files": [
                "forecasting.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T050",
        "name": "Design Multi Tenant Isolation",
        "task": {
          "id": "P2.T050",
          "feature_id": "F020",
          "title": "Design Multi Tenant Isolation",
          "description": "Design task for Multi Tenant Isolation",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f020-design.md",
                "docs/api/f020-openapi.yaml",
                "docs/schemas/f020-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Namespaced keys and configs per tenant.",
              "script": "test_p2.t050.sh"
            },
            {
              "type": "automated",
              "description": "Quotas and rate limits enforced; breaches reported.",
              "script": "test_p2.t050.sh"
            },
            {
              "type": "automated",
              "description": "Optional payload encryption with rotation.",
              "script": "test_p2.t050.sh"
            },
            {
              "type": "manual",
              "description": "Define tenant model and keying scheme",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement quotas/limits + integration with RL",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/multi-tenant-isolation.md",
              "excerpt": "Introduce first\u2011class tenant boundaries: per\u2011tenant queues/keys, quotas, rate limits, encryption\u2011at\u2011rest for payloads, and audit trails. Enable safe multi\u2011tenant deployments with predictable isolation",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Namespacing:",
              "Key scheme `t:{tenant}:{queue}` with strict validation; TUI filters by tenant.",
              "Tenant metadata store: quotas, limits, encryption keys policy.",
              "Quotas & limits:",
              "Integrate with Advanced Rate Limiting per tenant.",
              "Hard caps on backlog size and daily enqueues; soft warnings before enforcement.",
              "Encryption at rest (payload):",
              "Optional envelope encryption per tenant (AES\u2011GCM) with KEK via KMS; rotate data keys.",
              "Transparent decrypt for workers with tenant grants.",
              "Audit & RBAC:",
              "Scopes limited to `tenant:*` resources; audit tagged with tenant ID.",
              "Observability:",
              "Per\u2011tenant metrics and DLQ counts; TUI tenant switcher and summaries."
            ],
            "user_stories": [
              "I can define a tenant with quotas and limits and see them enforced.",
              "I can verify encryption on payloads and audit access by tenant."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T051",
        "name": "Implement Multi Tenant Isolation",
        "task": {
          "id": "P2.T051",
          "feature_id": "F020",
          "title": "Implement Multi Tenant Isolation",
          "description": "Implement task for Multi Tenant Isolation",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Namespaced keys and configs per tenant.",
                "Quotas and rate limits enforced; breaches reported.",
                "Optional payload encryption with rotation."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/multi-tenant-isolation/",
                "internal/multi-tenant-isolation/*_test.go",
                "docs/api/multi-tenant-isolation.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Namespaced keys and configs per tenant.",
              "script": "test_p2.t051.sh"
            },
            {
              "type": "automated",
              "description": "Quotas and rate limits enforced; breaches reported.",
              "script": "test_p2.t051.sh"
            },
            {
              "type": "automated",
              "description": "Optional payload encryption with rotation.",
              "script": "test_p2.t051.sh"
            },
            {
              "type": "manual",
              "description": "Define tenant model and keying scheme",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement quotas/limits + integration with RL",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/multi-tenant-isolation.md",
              "excerpt": "Introduce first\u2011class tenant boundaries: per\u2011tenant queues/keys, quotas, rate limits, encryption\u2011at\u2011rest for payloads, and audit trails. Enable safe multi\u2011tenant deployments with predictable isolation",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define tenant model and keying scheme",
              "Implement quotas/limits + integration with RL",
              "Add optional payload encryption",
              "Tenant\u2011aware RBAC + audit",
              "TUI tenant views + docs"
            ],
            "technical_approach": [
              "Namespacing:",
              "Key scheme `t:{tenant}:{queue}` with strict validation; TUI filters by tenant.",
              "Tenant metadata store: quotas, limits, encryption keys policy.",
              "Quotas & limits:",
              "Integrate with Advanced Rate Limiting per tenant.",
              "Hard caps on backlog size and daily enqueues; soft warnings before enforcement.",
              "Encryption at rest (payload):",
              "Optional envelope encryption per tenant (AES\u2011GCM) with KEK via KMS; rotate data keys.",
              "Transparent decrypt for workers with tenant grants.",
              "Audit & RBAC:",
              "Scopes limited to `tenant:*` resources; audit tagged with tenant ID.",
              "Observability:",
              "Per\u2011tenant metrics and DLQ counts; TUI tenant switcher and summaries."
            ],
            "code_structure": {
              "main_package": "internal/multi-tenant-isolation",
              "files": [
                "multi-tenant-isolation.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T052",
        "name": "Test Multi Tenant Isolation",
        "task": {
          "id": "P2.T052",
          "feature_id": "F020",
          "title": "Test Multi Tenant Isolation",
          "description": "Test task for Multi Tenant Isolation",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Namespaced keys and configs per tenant.",
              "script": "test_p2.t052.sh"
            },
            {
              "type": "automated",
              "description": "Quotas and rate limits enforced; breaches reported.",
              "script": "test_p2.t052.sh"
            },
            {
              "type": "automated",
              "description": "Optional payload encryption with rotation.",
              "script": "test_p2.t052.sh"
            },
            {
              "type": "manual",
              "description": "Define tenant model and keying scheme",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement quotas/limits + integration with RL",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/multi-tenant-isolation.md",
              "excerpt": "Introduce first\u2011class tenant boundaries: per\u2011tenant queues/keys, quotas, rate limits, encryption\u2011at\u2011rest for payloads, and audit trails. Enable safe multi\u2011tenant deployments with predictable isolation",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: quota accounting; encryption/decryption; key rotation."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: multi\u2011tenant soak with mixed loads and quota breaches."
                ],
                "priority": "high"
              },
              {
                "type": "security",
                "tests": [
                  "Security: attempt cross\u2011tenant access; verify denial and audit."
                ],
                "priority": "medium"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T053",
        "name": "Design Producer Backpressure",
        "task": {
          "id": "P3.T053",
          "feature_id": "F021",
          "title": "Design Producer Backpressure",
          "description": "Design task for Producer Backpressure",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f021-design.md",
                "docs/api/f021-openapi.yaml",
                "docs/schemas/f021-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Backpressure controller with thresholds and jittered polling.",
              "script": "test_p3.t053.sh"
            },
            {
              "type": "automated",
              "description": "Circuit breaker with configurable trip criteria and recovery.",
              "script": "test_p3.t053.sh"
            },
            {
              "type": "automated",
              "description": "Metrics exported for throttle and shed decisions.",
              "script": "test_p3.t053.sh"
            },
            {
              "type": "manual",
              "description": "Define thresholds and controller",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement Go SDK helper",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/producer-backpressure.md",
              "excerpt": "Provide producers with real\u2011time backpressure signals and helpers to adapt enqueue rate when queues are saturated. Offer SDK shims that expose `SuggestThrottle()` and circuit breaking by priority.\n\n> ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Signals:",
              "Poll Admin API stats (backlog length, age, rate limit budget) with jitter.",
              "Expose per\u2011queue thresholds and target backlog windows.",
              "Optional push channel via Event Hooks for threshold crossings.",
              "SDK helpers (Go first):",
              "`BackpressureController` with `SuggestThrottle()` returning sleep/delay hints.",
              "Circuit breaker for enqueue (open on sustained saturation; half\u2011open probes).",
              "Priority\u2011aware hints (high protected, low sheds first).",
              "Protocol hints:",
              "Include rate/budget headers in API responses when using HTTP Admin API.",
              "Producer integration:",
              "Simple wrapper: `bp.Run(ctx, func() { enqueue(...) })` schedules work to hints.",
              "Metrics: observed throttle, shed events, breaker state."
            ],
            "user_stories": [
              "I can adopt a small helper and see my enqueue smooth under saturation.",
              "I can see backpressure metrics and confirm fewer DLQs and timeouts."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T054",
        "name": "Implement Producer Backpressure",
        "task": {
          "id": "P3.T054",
          "feature_id": "F021",
          "title": "Implement Producer Backpressure",
          "description": "Implement task for Producer Backpressure",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Backpressure controller with thresholds and jittered polling.",
                "Circuit breaker with configurable trip criteria and recovery.",
                "Metrics exported for throttle and shed decisions."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/producer-backpressure/",
                "internal/producer-backpressure/*_test.go",
                "docs/api/producer-backpressure.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Backpressure controller with thresholds and jittered polling.",
              "script": "test_p3.t054.sh"
            },
            {
              "type": "automated",
              "description": "Circuit breaker with configurable trip criteria and recovery.",
              "script": "test_p3.t054.sh"
            },
            {
              "type": "automated",
              "description": "Metrics exported for throttle and shed decisions.",
              "script": "test_p3.t054.sh"
            },
            {
              "type": "manual",
              "description": "Define thresholds and controller",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement Go SDK helper",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/producer-backpressure.md",
              "excerpt": "Provide producers with real\u2011time backpressure signals and helpers to adapt enqueue rate when queues are saturated. Offer SDK shims that expose `SuggestThrottle()` and circuit breaking by priority.\n\n> ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define thresholds and controller",
              "Implement Go SDK helper",
              "Integrate Admin API hints",
              "Add TUI indicator + metrics",
              "Docs + examples"
            ],
            "technical_approach": [
              "Signals:",
              "Poll Admin API stats (backlog length, age, rate limit budget) with jitter.",
              "Expose per\u2011queue thresholds and target backlog windows.",
              "Optional push channel via Event Hooks for threshold crossings.",
              "SDK helpers (Go first):",
              "`BackpressureController` with `SuggestThrottle()` returning sleep/delay hints.",
              "Circuit breaker for enqueue (open on sustained saturation; half\u2011open probes).",
              "Priority\u2011aware hints (high protected, low sheds first).",
              "Protocol hints:",
              "Include rate/budget headers in API responses when using HTTP Admin API.",
              "Producer integration:",
              "Simple wrapper: `bp.Run(ctx, func() { enqueue(...) })` schedules work to hints.",
              "Metrics: observed throttle, shed events, breaker state."
            ],
            "code_structure": {
              "main_package": "internal/producer-backpressure",
              "files": [
                "producer-backpressure.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T055",
        "name": "Design Queue Snapshot Testing",
        "task": {
          "id": "P4.T055",
          "feature_id": "F022",
          "title": "Design Queue Snapshot Testing",
          "description": "Design task for Queue Snapshot Testing",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f022-design.md",
                "docs/api/f022-openapi.yaml",
                "docs/schemas/f022-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Snapshots capture complete queue state",
              "script": "test_p4.t055.sh"
            },
            {
              "type": "automated",
              "description": "Smart diff ignores non-semantic changes",
              "script": "test_p4.t055.sh"
            },
            {
              "type": "automated",
              "description": "Git integration with reasonable file sizes",
              "script": "test_p4.t055.sh"
            },
            {
              "type": "manual",
              "description": "<1s to save/load typical snapshots",
              "script": null
            },
            {
              "type": "manual",
              "description": "Design snapshot schema",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/queue-snapshot-testing.md",
              "excerpt": "Capture complete queue states as snapshots for regression testing, allowing teams to save, version, and replay complex queue scenarios. Compare actual vs. expected states with smart diffing that ignor",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Snapshot Capture:",
              "Complete state: all queues, jobs, workers, configs",
              "Deterministic serialization (sorted keys, normalized timestamps)",
              "Compression with zstd for storage efficiency",
              "Metadata: description, tags, creation context",
              "Snapshot Operations:",
              "Save: capture current state with name/description",
              "Load: restore queue to saved state",
              "Compare: diff two snapshots with smart filtering",
              "Assert: verify current state matches snapshot",
              "Smart Diffing:",
              "Ignore: timestamps (unless relative), job IDs, worker IDs",
              "Focus on: queue lengths, job payloads, failure patterns",
              "Configurable ignore patterns",
              "Semantic diff: understand moved vs. changed jobs",
              "Test Integration:",
              "Jest-style snapshot testing for Go",
              "CI/CD integration with snapshot repositories",
              "Automatic snapshot updates with approval flow",
              "Snapshot fixtures for different test scenarios",
              "Version Control:",
              "Store snapshots in git with large file support",
              "Track snapshot changes over time",
              "Branch-specific snapshot sets",
              "Merge conflict resolution tools",
              "TUI Features:",
              "Snapshot browser with search/filter",
              "Visual diff viewer with side-by-side comparison",
              "One-click save/load current state",
              "Snapshot \"albums\" for related scenarios"
            ],
            "user_stories": [
              "I can save queue state and assert it hasn't changed",
              "I can maintain a library of test scenarios",
              "I can review snapshot changes in pull requests"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T056",
        "name": "Implement Queue Snapshot Testing",
        "task": {
          "id": "P4.T056",
          "feature_id": "F022",
          "title": "Implement Queue Snapshot Testing",
          "description": "Implement task for Queue Snapshot Testing",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Snapshots capture complete queue state",
                "Smart diff ignores non-semantic changes",
                "Git integration with reasonable file sizes"
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/queue-snapshot-testing/",
                "internal/queue-snapshot-testing/*_test.go",
                "docs/api/queue-snapshot-testing.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Snapshots capture complete queue state",
              "script": "test_p4.t056.sh"
            },
            {
              "type": "automated",
              "description": "Smart diff ignores non-semantic changes",
              "script": "test_p4.t056.sh"
            },
            {
              "type": "automated",
              "description": "Git integration with reasonable file sizes",
              "script": "test_p4.t056.sh"
            },
            {
              "type": "manual",
              "description": "<1s to save/load typical snapshots",
              "script": null
            },
            {
              "type": "manual",
              "description": "Design snapshot schema",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/queue-snapshot-testing.md",
              "excerpt": "Capture complete queue states as snapshots for regression testing, allowing teams to save, version, and replay complex queue scenarios. Compare actual vs. expected states with smart diffing that ignor",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Design snapshot schema",
              "Implement state serialization",
              "Build smart diff engine",
              "Create test framework integration",
              "Add TUI snapshot browser",
              "Git workflow tooling",
              "Example snapshot library"
            ],
            "technical_approach": [
              "Snapshot Capture:",
              "Complete state: all queues, jobs, workers, configs",
              "Deterministic serialization (sorted keys, normalized timestamps)",
              "Compression with zstd for storage efficiency",
              "Metadata: description, tags, creation context",
              "Snapshot Operations:",
              "Save: capture current state with name/description",
              "Load: restore queue to saved state",
              "Compare: diff two snapshots with smart filtering",
              "Assert: verify current state matches snapshot",
              "Smart Diffing:",
              "Ignore: timestamps (unless relative), job IDs, worker IDs",
              "Focus on: queue lengths, job payloads, failure patterns",
              "Configurable ignore patterns",
              "Semantic diff: understand moved vs. changed jobs",
              "Test Integration:",
              "Jest-style snapshot testing for Go",
              "CI/CD integration with snapshot repositories",
              "Automatic snapshot updates with approval flow",
              "Snapshot fixtures for different test scenarios",
              "Version Control:",
              "Store snapshots in git with large file support",
              "Track snapshot changes over time",
              "Branch-specific snapshot sets",
              "Merge conflict resolution tools",
              "TUI Features:",
              "Snapshot browser with search/filter",
              "Visual diff viewer with side-by-side comparison",
              "One-click save/load current state",
              "Snapshot \"albums\" for related scenarios"
            ],
            "code_structure": {
              "main_package": "internal/queue-snapshot-testing",
              "files": [
                "queue-snapshot-testing.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T057",
        "name": "Design Smart Retry Strategies",
        "task": {
          "id": "P2.T057",
          "feature_id": "F023",
          "title": "Design Smart Retry Strategies",
          "description": "Design task for Smart Retry Strategies",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f023-design.md",
                "docs/api/f023-openapi.yaml",
                "docs/schemas/f023-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Baseline heuristics with jitter and caps in place.",
              "script": "test_p2.t057.sh"
            },
            {
              "type": "automated",
              "description": "Bayesian recommendations improve success/time tradeoff in test.",
              "script": "test_p2.t057.sh"
            },
            {
              "type": "automated",
              "description": "Optional ML can be enabled and rolled back safely.",
              "script": "test_p2.t057.sh"
            },
            {
              "type": "manual",
              "description": "Define schema for attempt history and features",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement rules + Bayesian recommender",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/smart-retry-strategies.md",
              "excerpt": "Adapt retry timing and policy based on historical success patterns. Start with robust heuristics and a Bayesian layer, optionally evolve to ML\u2011based recommendations. Bound decisions with guardrails an",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Data collection:",
              "Log features per attempt: error class/code, status, attempt number, queue/tenant, payload size, time of day, worker version, downstream health signals.",
              "Persist outcomes and delays; aggregate by error class and job type.",
              "Baseline policies:",
              "Rules for common cases: 429/503 \u2192 exponential + jitter with cap; timeouts \u2192 wider backoff; validation errors \u2192 stop early.",
              "Bayesian layer:",
              "For each (job_type, error_class), fit a simple model of success probability over delay since last failure (e.g., Beta\u2011Binomial buckets).",
              "Recommend next delay that crosses a success threshold with confidence, within min/max bounds.",
              "Optional ML:",
              "Train logistic regression or gradient boosting with cross\u2011validation; export small on\u2011disk model; inference library embedded.",
              "Version models; add canary evaluation before rollout.",
              "Policy guardrails:",
              "Hard caps on max attempts/delay; budget integration to avoid overload; per\u2011tenant fairness.",
              "Explainability: record \"why\" for each recommendation.",
              "Admin/TUI:",
              "API to preview recommended schedule for a failed sample; TUI shows suggested next retry window and rationale."
            ],
            "user_stories": [
              "I can see recommended next retry times and the reason.",
              "I can cap or override strategies per queue/tenant."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T058",
        "name": "Implement Smart Retry Strategies",
        "task": {
          "id": "P2.T058",
          "feature_id": "F023",
          "title": "Implement Smart Retry Strategies",
          "description": "Implement task for Smart Retry Strategies",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Baseline heuristics with jitter and caps in place.",
                "Bayesian recommendations improve success/time tradeoff in test.",
                "Optional ML can be enabled and rolled back safely."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/smart-retry-strategies/",
                "internal/smart-retry-strategies/*_test.go",
                "docs/api/smart-retry-strategies.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Baseline heuristics with jitter and caps in place.",
              "script": "test_p2.t058.sh"
            },
            {
              "type": "automated",
              "description": "Bayesian recommendations improve success/time tradeoff in test.",
              "script": "test_p2.t058.sh"
            },
            {
              "type": "automated",
              "description": "Optional ML can be enabled and rolled back safely.",
              "script": "test_p2.t058.sh"
            },
            {
              "type": "manual",
              "description": "Define schema for attempt history and features",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement rules + Bayesian recommender",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/smart-retry-strategies.md",
              "excerpt": "Adapt retry timing and policy based on historical success patterns. Start with robust heuristics and a Bayesian layer, optionally evolve to ML\u2011based recommendations. Bound decisions with guardrails an",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define schema for attempt history and features",
              "Implement rules + Bayesian recommender",
              "Add optional ML trainer/inference path",
              "Expose preview API + TUI surfacing",
              "Shadow \u2192 canary \u2192 full rollout"
            ],
            "technical_approach": [
              "Data collection:",
              "Log features per attempt: error class/code, status, attempt number, queue/tenant, payload size, time of day, worker version, downstream health signals.",
              "Persist outcomes and delays; aggregate by error class and job type.",
              "Baseline policies:",
              "Rules for common cases: 429/503 \u2192 exponential + jitter with cap; timeouts \u2192 wider backoff; validation errors \u2192 stop early.",
              "Bayesian layer:",
              "For each (job_type, error_class), fit a simple model of success probability over delay since last failure (e.g., Beta\u2011Binomial buckets).",
              "Recommend next delay that crosses a success threshold with confidence, within min/max bounds.",
              "Optional ML:",
              "Train logistic regression or gradient boosting with cross\u2011validation; export small on\u2011disk model; inference library embedded.",
              "Version models; add canary evaluation before rollout.",
              "Policy guardrails:",
              "Hard caps on max attempts/delay; budget integration to avoid overload; per\u2011tenant fairness.",
              "Explainability: record \"why\" for each recommendation.",
              "Admin/TUI:",
              "API to preview recommended schedule for a failed sample; TUI shows suggested next retry window and rationale."
            ],
            "code_structure": {
              "main_package": "internal/smart-retry-strategies",
              "files": [
                "smart-retry-strategies.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T059",
        "name": "Test Smart Retry Strategies",
        "task": {
          "id": "P2.T059",
          "feature_id": "F023",
          "title": "Test Smart Retry Strategies",
          "description": "Test task for Smart Retry Strategies",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Baseline heuristics with jitter and caps in place.",
              "script": "test_p2.t059.sh"
            },
            {
              "type": "automated",
              "description": "Bayesian recommendations improve success/time tradeoff in test.",
              "script": "test_p2.t059.sh"
            },
            {
              "type": "automated",
              "description": "Optional ML can be enabled and rolled back safely.",
              "script": "test_p2.t059.sh"
            },
            {
              "type": "manual",
              "description": "Define schema for attempt history and features",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement rules + Bayesian recommender",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/smart-retry-strategies.md",
              "excerpt": "Adapt retry timing and policy based on historical success patterns. Start with robust heuristics and a Bayesian layer, optionally evolve to ML\u2011based recommendations. Bound decisions with guardrails an",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: rules engine; Bayesian bucket math; cap enforcement."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: shadow mode where recommendations are logged, then A/B on a subset."
                ],
                "priority": "high"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T060",
        "name": "Design Storage Backends",
        "task": {
          "id": "P2.T060",
          "feature_id": "F024",
          "title": "Design Storage Backends",
          "description": "Design task for Storage Backends",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f024-design.md",
                "docs/api/f024-openapi.yaml",
                "docs/schemas/f024-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Backend interface with Lists + Streams implementations.",
              "script": "test_p2.t060.sh"
            },
            {
              "type": "automated",
              "description": "Redis Cluster support for key tagging and safe ops.",
              "script": "test_p2.t060.sh"
            },
            {
              "type": "automated",
              "description": "Migration tool and documentation.",
              "script": "test_p2.t060.sh"
            },
            {
              "type": "manual",
              "description": "Define interface + capability flags",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement Streams backend",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/storage-backends.md",
              "excerpt": "Abstract storage to support multiple engines: Redis Lists (current), Redis Streams, and optionally KeyDB/Dragonfly and Redis Cluster. Provide a pluggable interface and a Kafka outbox bridge for intero",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Abstraction:",
              "Define `QueueBackend` interface: Enqueue, Dequeue, Ack/Nack, Peek, Length, Move (DLQ), Iter.",
              "Capability flags (atomic ack, consumer groups, idempotency support).",
              "Implementations:",
              "Lists (baseline): current Redis lists; keep as default.",
              "Streams: use XADD/XREADGROUP; maintain consumer group per worker pool; handle pending/claim.",
              "Redis Cluster: key tags to route queues to slots; avoid cross\u2011slot ops.",
              "KeyDB/Dragonfly: validate compatibility; perf tuning knobs.",
              "Outbox bridge:",
              "Optional: publish enqueue events to Kafka topics; reconcile on failures.",
              "Config + migration:",
              "Backend selection per queue; migration tools (drain + copy) with safety.",
              "Observability:",
              "Metrics per backend; warnings for unsupported features; tests for ordering/ack semantics."
            ],
            "user_stories": [
              "I can choose Streams for a specific queue to enable replay and consumer groups.",
              "I can migrate a queue from Lists to Streams with a guided tool."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T061",
        "name": "Implement Storage Backends",
        "task": {
          "id": "P2.T061",
          "feature_id": "F024",
          "title": "Implement Storage Backends",
          "description": "Implement task for Storage Backends",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Backend interface with Lists + Streams implementations.",
                "Redis Cluster support for key tagging and safe ops.",
                "Migration tool and documentation."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/storage-backends/",
                "internal/storage-backends/*_test.go",
                "docs/api/storage-backends.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Backend interface with Lists + Streams implementations.",
              "script": "test_p2.t061.sh"
            },
            {
              "type": "automated",
              "description": "Redis Cluster support for key tagging and safe ops.",
              "script": "test_p2.t061.sh"
            },
            {
              "type": "automated",
              "description": "Migration tool and documentation.",
              "script": "test_p2.t061.sh"
            },
            {
              "type": "manual",
              "description": "Define interface + capability flags",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement Streams backend",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/storage-backends.md",
              "excerpt": "Abstract storage to support multiple engines: Redis Lists (current), Redis Streams, and optionally KeyDB/Dragonfly and Redis Cluster. Provide a pluggable interface and a Kafka outbox bridge for intero",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define interface + capability flags",
              "Implement Streams backend",
              "Add Cluster key tagging support",
              "Migration tooling",
              "Docs + benchmarks"
            ],
            "technical_approach": [
              "Abstraction:",
              "Define `QueueBackend` interface: Enqueue, Dequeue, Ack/Nack, Peek, Length, Move (DLQ), Iter.",
              "Capability flags (atomic ack, consumer groups, idempotency support).",
              "Implementations:",
              "Lists (baseline): current Redis lists; keep as default.",
              "Streams: use XADD/XREADGROUP; maintain consumer group per worker pool; handle pending/claim.",
              "Redis Cluster: key tags to route queues to slots; avoid cross\u2011slot ops.",
              "KeyDB/Dragonfly: validate compatibility; perf tuning knobs.",
              "Outbox bridge:",
              "Optional: publish enqueue events to Kafka topics; reconcile on failures.",
              "Config + migration:",
              "Backend selection per queue; migration tools (drain + copy) with safety.",
              "Observability:",
              "Metrics per backend; warnings for unsupported features; tests for ordering/ack semantics."
            ],
            "code_structure": {
              "main_package": "internal/storage-backends",
              "files": [
                "storage-backends.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P2.T062",
        "name": "Test Storage Backends",
        "task": {
          "id": "P2.T062",
          "feature_id": "F024",
          "title": "Test Storage Backends",
          "description": "Test task for Storage Backends",
          "boundaries": {
            "expected_complexity": {
              "value": "~600-800 LoC tests",
              "breakdown": "Unit (400), Integration (300), E2E (100)"
            },
            "definition_of_done": {
              "criteria": [
                "80% code coverage achieved",
                "All test scenarios passing",
                "Performance benchmarks validated",
                "Security tests passing",
                "No flaky tests",
                "Test documentation complete"
              ],
              "stop_when": "All tests green; do NOT refactor code"
            },
            "scope": {
              "includes": [
                "*_test.go files",
                "test/integration/",
                "test/e2e/",
                "test/fixtures/"
              ],
              "excludes": [
                "production code changes"
              ],
              "restrictions": "Tests must be deterministic and fast"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "unit",
                "at_percent": 40,
                "description": "Unit tests complete"
              },
              {
                "id": "integration",
                "at_percent": 70,
                "description": "Integration tests complete"
              },
              {
                "id": "e2e",
                "at_percent": 90,
                "description": "E2E tests complete"
              },
              {
                "id": "coverage",
                "at_percent": 100,
                "description": "Coverage targets met"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "testing",
              "golang",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 12
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 2
              },
              {
                "resource": "ci_runners",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Backend interface with Lists + Streams implementations.",
              "script": "test_p2.t062.sh"
            },
            {
              "type": "automated",
              "description": "Redis Cluster support for key tagging and safe ops.",
              "script": "test_p2.t062.sh"
            },
            {
              "type": "automated",
              "description": "Migration tool and documentation.",
              "script": "test_p2.t062.sh"
            },
            {
              "type": "manual",
              "description": "Define interface + capability flags",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement Streams backend",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/storage-backends.md",
              "excerpt": "Abstract storage to support multiple engines: Redis Lists (current), Redis Streams, and optionally KeyDB/Dragonfly and Redis Cluster. Provide a pluggable interface and a Kafka outbox bridge for intero",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "test_specification": {
            "test_categories": [
              {
                "type": "unit",
                "tests": [
                  "Unit: interface conformance; edge semantics (ack, pending claims)."
                ],
                "priority": "high"
              },
              {
                "type": "integration",
                "tests": [
                  "Integration: throughput/latency benchmarks; migration rehearsal."
                ],
                "priority": "high"
              }
            ],
            "coverage_requirements": {
              "unit": "80%",
              "integration": "70%",
              "e2e": "Critical paths only"
            },
            "test_data": [
              "Mock data generators",
              "Fixtures in test/fixtures/",
              "Dockerized dependencies"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T063",
        "name": "Design Terminal Voice Commands",
        "task": {
          "id": "P4.T063",
          "feature_id": "F025",
          "title": "Design Terminal Voice Commands",
          "description": "Design task for Terminal Voice Commands",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f025-design.md",
                "docs/api/f025-openapi.yaml",
                "docs/schemas/f025-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": ">90% accuracy for common commands in quiet environment",
              "script": "test_p4.t063.sh"
            },
            {
              "type": "automated",
              "description": "<500ms response time for local recognition",
              "script": "test_p4.t063.sh"
            },
            {
              "type": "automated",
              "description": "Support for 50+ command variations",
              "script": "test_p4.t063.sh"
            },
            {
              "type": "manual",
              "description": "Graceful degradation when recognition fails",
              "script": null
            },
            {
              "type": "manual",
              "description": "Integrate Whisper.cpp for local recognition",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/terminal-voice-commands.md",
              "excerpt": "Hands-free queue management through natural language voice commands. Speak to your terminal to perform operations, get status updates, and navigate the TUI\u2014improving accessibility and enabling multita",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Speech Recognition:",
              "Local: Whisper.cpp for privacy-conscious environments",
              "Cloud: Google Speech-to-Text or Azure Speech for accuracy",
              "Configurable backend with fallback options",
              "Wake word detection: \"Hey Queue\" or custom phrase",
              "Natural Language Processing:",
              "Intent recognition with simple pattern matching initially",
              "Command aliases and variations (\"drain worker 3\", \"stop the third worker\")",
              "Context awareness: remember recent commands",
              "Fuzzy matching for queue/worker names",
              "Command Grammar:",
              "Status queries: \"How many jobs in high priority?\"",
              "Actions: \"Requeue all failed jobs\", \"Drain worker 2\"",
              "Navigation: \"Show me the DLQ\", \"Go to charts\"",
              "Confirmations: \"Yes\", \"Cancel\", \"Confirm\"",
              "Audio Feedback:",
              "Text-to-speech for responses (optional)",
              "Audio cues for success/failure",
              "Adjustable voice personality",
              "Privacy & Security:",
              "Local-first processing option",
              "No audio recording by default",
              "Explicit opt-in for cloud services",
              "Sanitize sensitive data from voice logs",
              "TUI Integration:",
              "Voice indicator when listening",
              "Transcript display of recognized commands",
              "Visual feedback during processing",
              "Keyboard hotkey to activate (e.g., 'v')"
            ],
            "user_stories": [
              "I can manage queues without using keyboard/mouse",
              "I can query status while typing in another window",
              "I can execute complex commands with natural language"
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T064",
        "name": "Implement Terminal Voice Commands",
        "task": {
          "id": "P4.T064",
          "feature_id": "F025",
          "title": "Implement Terminal Voice Commands",
          "description": "Implement task for Terminal Voice Commands",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                ">90% accuracy for common commands in quiet environment",
                "<500ms response time for local recognition",
                "Support for 50+ command variations"
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/terminal-voice-commands/",
                "internal/terminal-voice-commands/*_test.go",
                "docs/api/terminal-voice-commands.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": ">90% accuracy for common commands in quiet environment",
              "script": "test_p4.t064.sh"
            },
            {
              "type": "automated",
              "description": "<500ms response time for local recognition",
              "script": "test_p4.t064.sh"
            },
            {
              "type": "automated",
              "description": "Support for 50+ command variations",
              "script": "test_p4.t064.sh"
            },
            {
              "type": "manual",
              "description": "Graceful degradation when recognition fails",
              "script": null
            },
            {
              "type": "manual",
              "description": "Integrate Whisper.cpp for local recognition",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/terminal-voice-commands.md",
              "excerpt": "Hands-free queue management through natural language voice commands. Speak to your terminal to perform operations, get status updates, and navigate the TUI\u2014improving accessibility and enabling multita",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Integrate Whisper.cpp for local recognition",
              "Build intent recognition system",
              "Create command grammar and aliases",
              "Add TUI voice indicators",
              "Implement audio feedback",
              "Cloud backend integration",
              "Accessibility testing"
            ],
            "technical_approach": [
              "Speech Recognition:",
              "Local: Whisper.cpp for privacy-conscious environments",
              "Cloud: Google Speech-to-Text or Azure Speech for accuracy",
              "Configurable backend with fallback options",
              "Wake word detection: \"Hey Queue\" or custom phrase",
              "Natural Language Processing:",
              "Intent recognition with simple pattern matching initially",
              "Command aliases and variations (\"drain worker 3\", \"stop the third worker\")",
              "Context awareness: remember recent commands",
              "Fuzzy matching for queue/worker names",
              "Command Grammar:",
              "Status queries: \"How many jobs in high priority?\"",
              "Actions: \"Requeue all failed jobs\", \"Drain worker 2\"",
              "Navigation: \"Show me the DLQ\", \"Go to charts\"",
              "Confirmations: \"Yes\", \"Cancel\", \"Confirm\"",
              "Audio Feedback:",
              "Text-to-speech for responses (optional)",
              "Audio cues for success/failure",
              "Adjustable voice personality",
              "Privacy & Security:",
              "Local-first processing option",
              "No audio recording by default",
              "Explicit opt-in for cloud services",
              "Sanitize sensitive data from voice logs",
              "TUI Integration:",
              "Voice indicator when listening",
              "Transcript display of recognized commands",
              "Visual feedback during processing",
              "Keyboard hotkey to activate (e.g., 'v')"
            ],
            "code_structure": {
              "main_package": "internal/terminal-voice-commands",
              "files": [
                "terminal-voice-commands.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T065",
        "name": "Design Theme Playground",
        "task": {
          "id": "P4.T065",
          "feature_id": "F026",
          "title": "Design Theme Playground",
          "description": "Design task for Theme Playground",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f026-design.md",
                "docs/api/f026-openapi.yaml",
                "docs/schemas/f026-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Theme registry with dark/light/high\u2011contrast.",
              "script": "test_p4.t065.sh"
            },
            {
              "type": "automated",
              "description": "Settings UI to preview/apply themes and tweak accent.",
              "script": "test_p4.t065.sh"
            },
            {
              "type": "automated",
              "description": "Persisted across sessions and machines (path shown in UI).",
              "script": "test_p4.t065.sh"
            },
            {
              "type": "manual",
              "description": "Define Theme struct + registry",
              "script": null
            },
            {
              "type": "manual",
              "description": "Replace hardcoded colors with theme lookups",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/theme-playground.md",
              "excerpt": "A centralized theme system with dark/light and high\u2011contrast palettes, plus a playground to preview and switch themes live. Persist preferences, expose a few tunables (accent, contrast), and ensure ac",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Theme core:",
              "Define a `Theme` struct (palettes, borders, emphasis, status colors) and a registry.",
              "Replace ad\u2011hoc Lip Gloss colors with theme lookups.",
              "Adaptive colors for dark/light terminals; high\u2011contrast variant.",
              "Playground:",
              "Settings tab adds a Theme section with preview tiles and quick toggle keys.",
              "Live apply to the whole app; animation optional to avoid flicker.",
              "Persistence:",
              "Save to a small state file (e.g., `$XDG_CONFIG_HOME/go-redis-wq/theme.json`).",
              "Respect `NO_COLOR` and minimal styles mode.",
              "Accessibility:",
              "Contrast checks for text vs background (WCAG-ish heuristic); badges for risky pairs.",
              "Provide a monochrome theme for limited terminals."
            ],
            "user_stories": [
              "I can switch themes quickly and persist my choice.",
              "I can choose a high\u2011contrast theme that remains readable everywhere."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T066",
        "name": "Implement Theme Playground",
        "task": {
          "id": "P4.T066",
          "feature_id": "F026",
          "title": "Implement Theme Playground",
          "description": "Implement task for Theme Playground",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Theme registry with dark/light/high\u2011contrast.",
                "Settings UI to preview/apply themes and tweak accent.",
                "Persisted across sessions and machines (path shown in UI)."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/theme-playground/",
                "internal/theme-playground/*_test.go",
                "docs/api/theme-playground.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Theme registry with dark/light/high\u2011contrast.",
              "script": "test_p4.t066.sh"
            },
            {
              "type": "automated",
              "description": "Settings UI to preview/apply themes and tweak accent.",
              "script": "test_p4.t066.sh"
            },
            {
              "type": "automated",
              "description": "Persisted across sessions and machines (path shown in UI).",
              "script": "test_p4.t066.sh"
            },
            {
              "type": "manual",
              "description": "Define Theme struct + registry",
              "script": null
            },
            {
              "type": "manual",
              "description": "Replace hardcoded colors with theme lookups",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/theme-playground.md",
              "excerpt": "A centralized theme system with dark/light and high\u2011contrast palettes, plus a playground to preview and switch themes live. Persist preferences, expose a few tunables (accent, contrast), and ensure ac",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Define Theme struct + registry",
              "Replace hardcoded colors with theme lookups",
              "Add Settings playground UI",
              "Persist preferences",
              "Docs + screenshots"
            ],
            "technical_approach": [
              "Theme core:",
              "Define a `Theme` struct (palettes, borders, emphasis, status colors) and a registry.",
              "Replace ad\u2011hoc Lip Gloss colors with theme lookups.",
              "Adaptive colors for dark/light terminals; high\u2011contrast variant.",
              "Playground:",
              "Settings tab adds a Theme section with preview tiles and quick toggle keys.",
              "Live apply to the whole app; animation optional to avoid flicker.",
              "Persistence:",
              "Save to a small state file (e.g., `$XDG_CONFIG_HOME/go-redis-wq/theme.json`).",
              "Respect `NO_COLOR` and minimal styles mode.",
              "Accessibility:",
              "Contrast checks for text vs background (WCAG-ish heuristic); badges for risky pairs.",
              "Provide a monochrome theme for limited terminals."
            ],
            "code_structure": {
              "main_package": "internal/theme-playground",
              "files": [
                "theme-playground.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T067",
        "name": "Design Trace Drilldown Log Tail",
        "task": {
          "id": "P4.T067",
          "feature_id": "F027",
          "title": "Design Trace Drilldown Log Tail",
          "description": "Design task for Trace Drilldown Log Tail",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f027-design.md",
                "docs/api/f027-openapi.yaml",
                "docs/schemas/f027-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Trace IDs visible in Peek/Info; action to open.",
              "script": "test_p4.t067.sh"
            },
            {
              "type": "automated",
              "description": "Log tail pane with follow mode, filters, and backpressure protection.",
              "script": "test_p4.t067.sh"
            },
            {
              "type": "automated",
              "description": "Configurable endpoints for tracing and logs.",
              "script": "test_p4.t067.sh"
            },
            {
              "type": "manual",
              "description": "Capture/propagate trace IDs",
              "script": null
            },
            {
              "type": "manual",
              "description": "Add Open Trace action",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/trace-drilldown-log-tail.md",
              "excerpt": "Surface trace IDs in the TUI and provide a log tail pane with filters to accelerate RCA.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Observability nirvana! Going from \"job failed\" to root cause in second",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Ensure trace IDs captured in payload/metadata; configurable tracing base URL.",
              "Add \u201cOpen Trace\u201d action (external link or inline spans summary).",
              "Implement lightweight log tailer with rate cap and filters by job/worker."
            ],
            "user_stories": [
              "I can open a job\u2019s trace from the TUI.",
              "I can tail logs filtered by job or worker."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T068",
        "name": "Implement Trace Drilldown Log Tail",
        "task": {
          "id": "P4.T068",
          "feature_id": "F027",
          "title": "Implement Trace Drilldown Log Tail",
          "description": "Implement task for Trace Drilldown Log Tail",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Trace IDs visible in Peek/Info; action to open.",
                "Log tail pane with follow mode, filters, and backpressure protection.",
                "Configurable endpoints for tracing and logs."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/trace-drilldown-log-tail/",
                "internal/trace-drilldown-log-tail/*_test.go",
                "docs/api/trace-drilldown-log-tail.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Trace IDs visible in Peek/Info; action to open.",
              "script": "test_p4.t068.sh"
            },
            {
              "type": "automated",
              "description": "Log tail pane with follow mode, filters, and backpressure protection.",
              "script": "test_p4.t068.sh"
            },
            {
              "type": "automated",
              "description": "Configurable endpoints for tracing and logs.",
              "script": "test_p4.t068.sh"
            },
            {
              "type": "manual",
              "description": "Capture/propagate trace IDs",
              "script": null
            },
            {
              "type": "manual",
              "description": "Add Open Trace action",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/trace-drilldown-log-tail.md",
              "excerpt": "Surface trace IDs in the TUI and provide a log tail pane with filters to accelerate RCA.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Observability nirvana! Going from \"job failed\" to root cause in second",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Capture/propagate trace IDs",
              "Add Open Trace action",
              "Implement log tail pane with filters",
              "Docs and examples"
            ],
            "technical_approach": [
              "Ensure trace IDs captured in payload/metadata; configurable tracing base URL.",
              "Add \u201cOpen Trace\u201d action (external link or inline spans summary).",
              "Implement lightweight log tailer with rate cap and filters by job/worker."
            ],
            "code_structure": {
              "main_package": "internal/trace-drilldown-log-tail",
              "files": [
                "trace-drilldown-log-tail.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T069",
        "name": "Design Dlq Remediation Ui",
        "task": {
          "id": "P3.T069",
          "feature_id": "F028",
          "title": "Design Dlq Remediation Ui",
          "description": "Design task for Dlq Remediation Ui",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f028-design.md",
                "docs/api/f028-openapi.yaml",
                "docs/schemas/f028-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "DLQ list is paginated with total count and filter.",
              "script": "test_p3.t069.sh"
            },
            {
              "type": "automated",
              "description": "Peek shows pretty JSON and metadata.",
              "script": "test_p3.t069.sh"
            },
            {
              "type": "automated",
              "description": "Requeue/Purge actions exist for selected items; purge all gated by confirm.",
              "script": "test_p3.t069.sh"
            },
            {
              "type": "manual",
              "description": "Handles large DLQs without freezing the UI.",
              "script": null
            },
            {
              "type": "manual",
              "description": "API: list + count with filters",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/dlq-remediation-ui.md",
              "excerpt": "A focused DLQ tab to list, search, peek, requeue, and purge items safely with confirmations.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> THIS is what separates toy queues from production queues. Every on",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "API: add DLQ list with pagination, peek by index/ID, requeue selected, purge endpoints.",
              "TUI: DLQ tab with pager, filter, selection; action bar; confirmations.",
              "Performance: server-side pagination; cap payload sizes; streaming where feasible."
            ],
            "user_stories": [
              "I can list and filter DLQ items and peek payloads.",
              "I can requeue or purge selected items with confirmation."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T070",
        "name": "Implement Dlq Remediation Ui",
        "task": {
          "id": "P3.T070",
          "feature_id": "F028",
          "title": "Implement Dlq Remediation Ui",
          "description": "Implement task for Dlq Remediation Ui",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "DLQ list is paginated with total count and filter.",
                "Peek shows pretty JSON and metadata.",
                "Requeue/Purge actions exist for selected items; purge all gated by confirm."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/dlq-remediation-ui/",
                "internal/dlq-remediation-ui/*_test.go",
                "docs/api/dlq-remediation-ui.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "DLQ list is paginated with total count and filter.",
              "script": "test_p3.t070.sh"
            },
            {
              "type": "automated",
              "description": "Peek shows pretty JSON and metadata.",
              "script": "test_p3.t070.sh"
            },
            {
              "type": "automated",
              "description": "Requeue/Purge actions exist for selected items; purge all gated by confirm.",
              "script": "test_p3.t070.sh"
            },
            {
              "type": "manual",
              "description": "Handles large DLQs without freezing the UI.",
              "script": null
            },
            {
              "type": "manual",
              "description": "API: list + count with filters",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/dlq-remediation-ui.md",
              "excerpt": "A focused DLQ tab to list, search, peek, requeue, and purge items safely with confirmations.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> THIS is what separates toy queues from production queues. Every on",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "API: list + count with filters",
              "API: peek item by ID/index",
              "API: requeue selected",
              "API: purge selected/all",
              "TUI: DLQ tab UI + pager + actions",
              "Docs + screenshots"
            ],
            "technical_approach": [
              "API: add DLQ list with pagination, peek by index/ID, requeue selected, purge endpoints.",
              "TUI: DLQ tab with pager, filter, selection; action bar; confirmations.",
              "Performance: server-side pagination; cap payload sizes; streaming where feasible."
            ],
            "code_structure": {
              "main_package": "internal/dlq-remediation-ui",
              "files": [
                "dlq-remediation-ui.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T071",
        "name": "Design Dlq Remediation Pipeline",
        "task": {
          "id": "P3.T071",
          "feature_id": "F029",
          "title": "Design Dlq Remediation Pipeline",
          "description": "Design task for Dlq Remediation Pipeline",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f029-design.md",
                "docs/api/f029-openapi.yaml",
                "docs/schemas/f029-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Classifier + actions with rate caps and idempotency.",
              "script": "test_p3.t071.sh"
            },
            {
              "type": "automated",
              "description": "Dry\u2011run and audit log of changes.",
              "script": "test_p3.t071.sh"
            },
            {
              "type": "automated",
              "description": "TUI shows rule results and counters.",
              "script": "test_p3.t071.sh"
            },
            {
              "type": "manual",
              "description": "Rule schema + storage",
              "script": null
            },
            {
              "type": "manual",
              "description": "Classifier engine + optional external hook",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/dlq-remediation-pipeline.md",
              "excerpt": "Automate DLQ cleanup with a configurable pipeline: classify failures, apply rules (transform, redact, reroute), and requeue with safe limits. Provide dry\u2011run, audit, and guardrails to reduce incident ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Classification:",
              "Pluggable matchers: error substrings/regex, fields in payload, origin queue, retry count.",
              "Optional external classifier hook (HTTP/NATS) for complex decisions.",
              "Remediation actions:",
              "Requeue to original or alternate queue; transform payload; redact fields; drop.",
              "Caps: max per minute, max total, stop on error rate spike.",
              "Pipeline engine:",
              "Poll DLQ or subscribe to events; batch evaluate; apply actions with idempotency keys.",
              "Track outcome metrics and write audit entries.",
              "TUI integration:",
              "Rule editor (basic); simulation mode on sample DLQ slice; live counters.",
              "Safety:",
              "Dry\u2011run mode with diff; explicit confirm to apply.",
              "Blacklist of non\u2011retryable errors; TTL for requeued items."
            ],
            "user_stories": [
              "I can define a rule that requeues validation errors after redacting a field.",
              "I can run a dry\u2011run on 100 DLQ items and review the plan."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T072",
        "name": "Implement Dlq Remediation Pipeline",
        "task": {
          "id": "P3.T072",
          "feature_id": "F029",
          "title": "Implement Dlq Remediation Pipeline",
          "description": "Implement task for Dlq Remediation Pipeline",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Classifier + actions with rate caps and idempotency.",
                "Dry\u2011run and audit log of changes.",
                "TUI shows rule results and counters."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/dlq-remediation-pipeline/",
                "internal/dlq-remediation-pipeline/*_test.go",
                "docs/api/dlq-remediation-pipeline.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Classifier + actions with rate caps and idempotency.",
              "script": "test_p3.t072.sh"
            },
            {
              "type": "automated",
              "description": "Dry\u2011run and audit log of changes.",
              "script": "test_p3.t072.sh"
            },
            {
              "type": "automated",
              "description": "TUI shows rule results and counters.",
              "script": "test_p3.t072.sh"
            },
            {
              "type": "manual",
              "description": "Rule schema + storage",
              "script": null
            },
            {
              "type": "manual",
              "description": "Classifier engine + optional external hook",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/dlq-remediation-pipeline.md",
              "excerpt": "Automate DLQ cleanup with a configurable pipeline: classify failures, apply rules (transform, redact, reroute), and requeue with safe limits. Provide dry\u2011run, audit, and guardrails to reduce incident ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Rule schema + storage",
              "Classifier engine + optional external hook",
              "Actions (requeue/transform/redact/drop)",
              "Dry\u2011run + audit + metrics",
              "TUI rule editor + counters"
            ],
            "technical_approach": [
              "Classification:",
              "Pluggable matchers: error substrings/regex, fields in payload, origin queue, retry count.",
              "Optional external classifier hook (HTTP/NATS) for complex decisions.",
              "Remediation actions:",
              "Requeue to original or alternate queue; transform payload; redact fields; drop.",
              "Caps: max per minute, max total, stop on error rate spike.",
              "Pipeline engine:",
              "Poll DLQ or subscribe to events; batch evaluate; apply actions with idempotency keys.",
              "Track outcome metrics and write audit entries.",
              "TUI integration:",
              "Rule editor (basic); simulation mode on sample DLQ slice; live counters.",
              "Safety:",
              "Dry\u2011run mode with diff; explicit confirm to apply.",
              "Blacklist of non\u2011retryable errors; TTL for requeued items."
            ],
            "code_structure": {
              "main_package": "internal/dlq-remediation-pipeline",
              "files": [
                "dlq-remediation-pipeline.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T073",
        "name": "Design Patterned Load Generator",
        "task": {
          "id": "P4.T073",
          "feature_id": "F030",
          "title": "Design Patterned Load Generator",
          "description": "Design task for Patterned Load Generator",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f030-design.md",
                "docs/api/f030-openapi.yaml",
                "docs/schemas/f030-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Sine, burst, ramp patterns; cancel/stop supported.",
              "script": "test_p4.t073.sh"
            },
            {
              "type": "automated",
              "description": "Guardrails prevent runaway load.",
              "script": "test_p4.t073.sh"
            },
            {
              "type": "automated",
              "description": "Saved profiles can be reloaded.",
              "script": "test_p4.t073.sh"
            },
            {
              "type": "manual",
              "description": "Implement sine/burst/ramp",
              "script": null
            },
            {
              "type": "manual",
              "description": "Add controls + guardrails",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/patterned-load-generator.md",
              "excerpt": "Extend the bench tool to support sine/burst/ramp patterns, with guardrails and live visualization.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Smart evolution of your existing bench tool! Sine waves for ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Implement pattern generators; controls for duration/amplitude; guardrails (max rate/total).",
              "Overlay target vs actual enqueue rate on charts; profile persistence optional."
            ],
            "user_stories": [
              "I can run predefined patterns and see accurate live charts."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T074",
        "name": "Implement Patterned Load Generator",
        "task": {
          "id": "P4.T074",
          "feature_id": "F030",
          "title": "Implement Patterned Load Generator",
          "description": "Implement task for Patterned Load Generator",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Sine, burst, ramp patterns; cancel/stop supported.",
                "Guardrails prevent runaway load.",
                "Saved profiles can be reloaded."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/patterned-load-generator/",
                "internal/patterned-load-generator/*_test.go",
                "docs/api/patterned-load-generator.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Sine, burst, ramp patterns; cancel/stop supported.",
              "script": "test_p4.t074.sh"
            },
            {
              "type": "automated",
              "description": "Guardrails prevent runaway load.",
              "script": "test_p4.t074.sh"
            },
            {
              "type": "automated",
              "description": "Saved profiles can be reloaded.",
              "script": "test_p4.t074.sh"
            },
            {
              "type": "manual",
              "description": "Implement sine/burst/ramp",
              "script": null
            },
            {
              "type": "manual",
              "description": "Add controls + guardrails",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/patterned-load-generator.md",
              "excerpt": "Extend the bench tool to support sine/burst/ramp patterns, with guardrails and live visualization.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Smart evolution of your existing bench tool! Sine waves for ",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Implement sine/burst/ramp",
              "Add controls + guardrails",
              "Chart overlay target vs actual",
              "Save/load profiles"
            ],
            "technical_approach": [
              "Implement pattern generators; controls for duration/amplitude; guardrails (max rate/total).",
              "Overlay target vs actual enqueue rate on charts; profile persistence optional."
            ],
            "code_structure": {
              "main_package": "internal/patterned-load-generator",
              "files": [
                "patterned-load-generator.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T075",
        "name": "Design Policy Simulator",
        "task": {
          "id": "P4.T075",
          "feature_id": "F031",
          "title": "Design Policy Simulator",
          "description": "Design task for Policy Simulator",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f031-design.md",
                "docs/api/f031-openapi.yaml",
                "docs/schemas/f031-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "UI sliders/inputs for core policies; charts update with predictions.",
              "script": "test_p4.t075.sh"
            },
            {
              "type": "automated",
              "description": "Clear assumptions and limitations documented inline.",
              "script": "test_p4.t075.sh"
            },
            {
              "type": "automated",
              "description": "Apply/rollback via Admin API with audit log.",
              "script": "test_p4.t075.sh"
            },
            {
              "type": "manual",
              "description": "Implement core sim model",
              "script": null
            },
            {
              "type": "manual",
              "description": "UI: controls + charts",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/policy-simulator.md",
              "excerpt": "A \"what\u2011if\" simulator to preview the impact of policy changes (retry/backoff, rate limits, concurrency) before applying.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Ambitious! This is chaos engineering m",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Build a first\u2011order queueing model; configurable traffic patterns; show predicted backlog/throughput/latency.",
              "Integrate apply/rollback via Admin API; include audit trail."
            ],
            "user_stories": [
              "I can simulate and apply policy changes with confidence."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T076",
        "name": "Implement Policy Simulator",
        "task": {
          "id": "P4.T076",
          "feature_id": "F031",
          "title": "Implement Policy Simulator",
          "description": "Implement task for Policy Simulator",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "UI sliders/inputs for core policies; charts update with predictions.",
                "Clear assumptions and limitations documented inline.",
                "Apply/rollback via Admin API with audit log."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/policy-simulator/",
                "internal/policy-simulator/*_test.go",
                "docs/api/policy-simulator.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "UI sliders/inputs for core policies; charts update with predictions.",
              "script": "test_p4.t076.sh"
            },
            {
              "type": "automated",
              "description": "Clear assumptions and limitations documented inline.",
              "script": "test_p4.t076.sh"
            },
            {
              "type": "automated",
              "description": "Apply/rollback via Admin API with audit log.",
              "script": "test_p4.t076.sh"
            },
            {
              "type": "manual",
              "description": "Implement core sim model",
              "script": null
            },
            {
              "type": "manual",
              "description": "UI: controls + charts",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/policy-simulator.md",
              "excerpt": "A \"what\u2011if\" simulator to preview the impact of policy changes (retry/backoff, rate limits, concurrency) before applying.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'S THOUGHTS \ud83d\udcad**\n> Ambitious! This is chaos engineering m",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Implement core sim model",
              "UI: controls + charts",
              "Admin API: apply/rollback endpoints",
              "Docs + inline assumptions"
            ],
            "technical_approach": [
              "Build a first\u2011order queueing model; configurable traffic patterns; show predicted backlog/throughput/latency.",
              "Integrate apply/rollback via Admin API; include audit trail."
            ],
            "code_structure": {
              "main_package": "internal/policy-simulator",
              "files": [
                "policy-simulator.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T077",
        "name": "Design Advanced Rate Limiting",
        "task": {
          "id": "P3.T077",
          "feature_id": "F032",
          "title": "Design Advanced Rate Limiting",
          "description": "Design task for Advanced Rate Limiting",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f032-design.md",
                "docs/api/f032-openapi.yaml",
                "docs/schemas/f032-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Atomic token check/consume with Lua and proper TTLs.",
              "script": "test_p3.t077.sh"
            },
            {
              "type": "automated",
              "description": "Priority weights influence throughput under contention.",
              "script": "test_p3.t077.sh"
            },
            {
              "type": "automated",
              "description": "Admin API updates limits without restart; dry\u2011run previews impact.",
              "script": "test_p3.t077.sh"
            },
            {
              "type": "manual",
              "description": "Lua script + Go wrapper",
              "script": null
            },
            {
              "type": "manual",
              "description": "Config + Admin API endpoints",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/advanced-rate-limiting.md",
              "excerpt": "Implement token\u2011bucket rate limiting with priority fairness and per\u2011tenant budgets. Support global and per\u2011queue/per\u2011tenant limits, dynamic tuning, and clear visibility into allowance and throttling.\n",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Algorithms:",
              "Token bucket per key (`tenant:queue`) with refill rate and burst capacity.",
              "Priority fairness: weighted sharing between priorities (e.g., high=3, low=1) via separate buckets and proportional scheduling.",
              "Global cap: aggregate bucket above tenants to ensure cluster ceiling.",
              "Storage & atomicity:",
              "Redis Lua script to check/consume tokens atomically; returns `allow`, `wait_ms`, and remaining tokens.",
              "Keys: `rl:{scope}` with TTL; metadata hash for config.",
              "Configuration:",
              "Static config + Admin API to update rates and weights at runtime.",
              "Safe bounds and validation; dry\u2011run mode for tuning.",
              "Integration points:",
              "Producer side (enqueue): soft backpressure suggestions.",
              "Worker pull: throttle consumption when budget depleted.",
              "TUI: status widget showing budget/usage and recent throttles.",
              "Observability:",
              "Metrics: allowed/denied, wait times, bucket fill; per scope and aggregate.",
              "Debug endpoint to inspect current limits for a scope."
            ],
            "user_stories": [
              "I can set per\u2011tenant caps and verify they\u2019re enforced.",
              "I can see when throttling occurs and why."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T078",
        "name": "Implement Advanced Rate Limiting",
        "task": {
          "id": "P3.T078",
          "feature_id": "F032",
          "title": "Implement Advanced Rate Limiting",
          "description": "Implement task for Advanced Rate Limiting",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Atomic token check/consume with Lua and proper TTLs.",
                "Priority weights influence throughput under contention.",
                "Admin API updates limits without restart; dry\u2011run previews impact."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/advanced-rate-limiting/",
                "internal/advanced-rate-limiting/*_test.go",
                "docs/api/advanced-rate-limiting.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Atomic token check/consume with Lua and proper TTLs.",
              "script": "test_p3.t078.sh"
            },
            {
              "type": "automated",
              "description": "Priority weights influence throughput under contention.",
              "script": "test_p3.t078.sh"
            },
            {
              "type": "automated",
              "description": "Admin API updates limits without restart; dry\u2011run previews impact.",
              "script": "test_p3.t078.sh"
            },
            {
              "type": "manual",
              "description": "Lua script + Go wrapper",
              "script": null
            },
            {
              "type": "manual",
              "description": "Config + Admin API endpoints",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/advanced-rate-limiting.md",
              "excerpt": "Implement token\u2011bucket rate limiting with priority fairness and per\u2011tenant budgets. Support global and per\u2011queue/per\u2011tenant limits, dynamic tuning, and clear visibility into allowance and throttling.\n",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Lua script + Go wrapper",
              "Config + Admin API endpoints",
              "Producer hints + worker integration",
              "TUI widget + metrics",
              "Docs + examples"
            ],
            "technical_approach": [
              "Algorithms:",
              "Token bucket per key (`tenant:queue`) with refill rate and burst capacity.",
              "Priority fairness: weighted sharing between priorities (e.g., high=3, low=1) via separate buckets and proportional scheduling.",
              "Global cap: aggregate bucket above tenants to ensure cluster ceiling.",
              "Storage & atomicity:",
              "Redis Lua script to check/consume tokens atomically; returns `allow`, `wait_ms`, and remaining tokens.",
              "Keys: `rl:{scope}` with TTL; metadata hash for config.",
              "Configuration:",
              "Static config + Admin API to update rates and weights at runtime.",
              "Safe bounds and validation; dry\u2011run mode for tuning.",
              "Integration points:",
              "Producer side (enqueue): soft backpressure suggestions.",
              "Worker pull: throttle consumption when budget depleted.",
              "TUI: status widget showing budget/usage and recent throttles.",
              "Observability:",
              "Metrics: allowed/denied, wait times, bucket fill; per scope and aggregate.",
              "Debug endpoint to inspect current limits for a scope."
            ],
            "code_structure": {
              "main_package": "internal/advanced-rate-limiting",
              "files": [
                "advanced-rate-limiting.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T079",
        "name": "Design Calendar View",
        "task": {
          "id": "P4.T079",
          "feature_id": "F033",
          "title": "Design Calendar View",
          "description": "Design task for Calendar View",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f033-design.md",
                "docs/api/f033-openapi.yaml",
                "docs/schemas/f033-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Month/Week/Day views with keyboard navigation and counts.",
              "script": "test_p4.t079.sh"
            },
            {
              "type": "automated",
              "description": "Reschedule flow updates ZSET timestamp and reflects in view.",
              "script": "test_p4.t079.sh"
            },
            {
              "type": "automated",
              "description": "CRUD for recurring rules with pause/resume.",
              "script": "test_p4.t079.sh"
            },
            {
              "type": "manual",
              "description": "Admin API: schedules window + rules CRUD",
              "script": null
            },
            {
              "type": "manual",
              "description": "TUI: month/week/day views + navigation",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/calendar-view.md",
              "excerpt": "A calendar UI to visualize scheduled and recurring jobs by day/week/month. Users can navigate time ranges, inspect details, reschedule, or pause rules\u2014without leaving the TUI.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Data model:",
              "Scheduled jobs: Redis ZSET per queue (score = epoch seconds) or existing schedule store; list endpoints per time window.",
              "Recurring rules: store cron spec + metadata (timezone, jitter, max in\u2011flight).",
              "Admin API:",
              "List scheduled window: `/schedules?from&till&queue` returns items and counts.",
              "CRUD recurring rules: create, pause/resume, delete.",
              "Reschedule: move item to a new timestamp (idempotent re\u2011enqueue at time T).",
              "TUI:",
              "Views: Month (heatmap), Week (grid by day), Day (timeline).",
              "Navigation: `h/j/k/l` or arrow keys, `[`/`]` to shift range, `g/G` to jump today/end.",
              "Actions: enter to inspect, `r` to reschedule, `p` to pause rule, `/` filter by queue/tag.",
              "Rendering: compact cells with count badges; tooltip/overlay for dense cells using `bubblezone` hitboxes.",
              "Safety: timezone explicit in header; confirmation on reschedules; audit entries for changes.",
              "Observability: counts per bucket, peak hour visualization; errors surfaced inline."
            ],
            "user_stories": [
              "I can see scheduled volume per day and drill into a day to inspect items.",
              "I can reschedule an item and confirm the exact new time and queue.",
              "I can pause/resume a recurring rule and see status reflected immediately."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T080",
        "name": "Implement Calendar View",
        "task": {
          "id": "P4.T080",
          "feature_id": "F033",
          "title": "Implement Calendar View",
          "description": "Implement task for Calendar View",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Month/Week/Day views with keyboard navigation and counts.",
                "Reschedule flow updates ZSET timestamp and reflects in view.",
                "CRUD for recurring rules with pause/resume."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/calendar-view/",
                "internal/calendar-view/*_test.go",
                "docs/api/calendar-view.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Month/Week/Day views with keyboard navigation and counts.",
              "script": "test_p4.t080.sh"
            },
            {
              "type": "automated",
              "description": "Reschedule flow updates ZSET timestamp and reflects in view.",
              "script": "test_p4.t080.sh"
            },
            {
              "type": "automated",
              "description": "CRUD for recurring rules with pause/resume.",
              "script": "test_p4.t080.sh"
            },
            {
              "type": "manual",
              "description": "Admin API: schedules window + rules CRUD",
              "script": null
            },
            {
              "type": "manual",
              "description": "TUI: month/week/day views + navigation",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/calendar-view.md",
              "excerpt": "A calendar UI to visualize scheduled and recurring jobs by day/week/month. Users can navigate time ranges, inspect details, reschedule, or pause rules\u2014without leaving the TUI.\n\n> [!note]- **\ud83d\udde3\ufe0f CLAUDE'",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Admin API: schedules window + rules CRUD",
              "TUI: month/week/day views + navigation",
              "Reschedule flow + confirmations",
              "Pause/resume rules + indicators",
              "Docs + screenshots"
            ],
            "technical_approach": [
              "Data model:",
              "Scheduled jobs: Redis ZSET per queue (score = epoch seconds) or existing schedule store; list endpoints per time window.",
              "Recurring rules: store cron spec + metadata (timezone, jitter, max in\u2011flight).",
              "Admin API:",
              "List scheduled window: `/schedules?from&till&queue` returns items and counts.",
              "CRUD recurring rules: create, pause/resume, delete.",
              "Reschedule: move item to a new timestamp (idempotent re\u2011enqueue at time T).",
              "TUI:",
              "Views: Month (heatmap), Week (grid by day), Day (timeline).",
              "Navigation: `h/j/k/l` or arrow keys, `[`/`]` to shift range, `g/G` to jump today/end.",
              "Actions: enter to inspect, `r` to reschedule, `p` to pause rule, `/` filter by queue/tag.",
              "Rendering: compact cells with count badges; tooltip/overlay for dense cells using `bubblezone` hitboxes.",
              "Safety: timezone explicit in header; confirmation on reschedules; audit entries for changes.",
              "Observability: counts per bucket, peak hour visualization; errors surfaced inline."
            ],
            "code_structure": {
              "main_package": "internal/calendar-view",
              "files": [
                "calendar-view.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T081",
        "name": "Design Collaborative Session",
        "task": {
          "id": "P4.T081",
          "feature_id": "F034",
          "title": "Design Collaborative Session",
          "description": "Design task for Collaborative Session",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f034-design.md",
                "docs/api/f034-openapi.yaml",
                "docs/schemas/f034-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Read\u2011only viewing with smooth updates under typical terminal sizes.",
              "script": "test_p4.t081.sh"
            },
            {
              "type": "automated",
              "description": "Secure token\u2011based auth with expiry; control handoff flow.",
              "script": "test_p4.t081.sh"
            },
            {
              "type": "automated",
              "description": "Redaction of configured secrets in frames.",
              "script": "test_p4.t081.sh"
            },
            {
              "type": "manual",
              "description": "Session server + transport",
              "script": null
            },
            {
              "type": "manual",
              "description": "Presenter/observer UI + handoff",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/collaborative-session.md",
              "excerpt": "Share a read\u2011only live TUI session over the network. A presenter can invite observers to follow along; optionally hand control with a key press. Perfect for incident reviews, pairing, and demos\u2014withou",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Architecture:",
              "Session host multiplexes TUI output and input events over a secure transport.",
              "Observers receive frame deltas; optional control token to accept input.",
              "Transport & security:",
              "Default: SSH port forwarding or WebSocket over TLS to a small embedded server.",
              "Auth: one\u2011time session token with expiry; optional mTLS.",
              "Permissions: read\u2011only by default; control handoff requires explicit approval.",
              "TUI integration:",
              "Presenter mode indicator; participant list; handoff prompt; control timeout.",
              "Frame capture with minimal diff encoding (lines changed per tick) to keep CPU low.",
              "Observability:",
              "Session logs: joins/leaves, handoffs, duration.",
              "Metrics: active sessions, participants, bandwidth.",
              "Safety: redact sensitive values in frames (configurable patterns) before broadcast."
            ],
            "user_stories": [
              "I can start a collaborative session and share a link/token for read\u2011only viewing.",
              "I can hand control to a participant temporarily and revoke it easily."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T082",
        "name": "Implement Collaborative Session",
        "task": {
          "id": "P4.T082",
          "feature_id": "F034",
          "title": "Implement Collaborative Session",
          "description": "Implement task for Collaborative Session",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Read\u2011only viewing with smooth updates under typical terminal sizes.",
                "Secure token\u2011based auth with expiry; control handoff flow.",
                "Redaction of configured secrets in frames."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/collaborative-session/",
                "internal/collaborative-session/*_test.go",
                "docs/api/collaborative-session.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Read\u2011only viewing with smooth updates under typical terminal sizes.",
              "script": "test_p4.t082.sh"
            },
            {
              "type": "automated",
              "description": "Secure token\u2011based auth with expiry; control handoff flow.",
              "script": "test_p4.t082.sh"
            },
            {
              "type": "automated",
              "description": "Redaction of configured secrets in frames.",
              "script": "test_p4.t082.sh"
            },
            {
              "type": "manual",
              "description": "Session server + transport",
              "script": null
            },
            {
              "type": "manual",
              "description": "Presenter/observer UI + handoff",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/collaborative-session.md",
              "excerpt": "Share a read\u2011only live TUI session over the network. A presenter can invite observers to follow along; optionally hand control with a key press. Perfect for incident reviews, pairing, and demos\u2014withou",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Session server + transport",
              "Presenter/observer UI + handoff",
              "Token auth + expiry",
              "Redaction + metrics",
              "Docs + demo scripts"
            ],
            "technical_approach": [
              "Architecture:",
              "Session host multiplexes TUI output and input events over a secure transport.",
              "Observers receive frame deltas; optional control token to accept input.",
              "Transport & security:",
              "Default: SSH port forwarding or WebSocket over TLS to a small embedded server.",
              "Auth: one\u2011time session token with expiry; optional mTLS.",
              "Permissions: read\u2011only by default; control handoff requires explicit approval.",
              "TUI integration:",
              "Presenter mode indicator; participant list; handoff prompt; control timeout.",
              "Frame capture with minimal diff encoding (lines changed per tick) to keep CPU low.",
              "Observability:",
              "Session logs: joins/leaves, handoffs, duration.",
              "Metrics: active sessions, participants, bandwidth.",
              "Safety: redact sensitive values in frames (configurable patterns) before broadcast."
            ],
            "code_structure": {
              "main_package": "internal/collaborative-session",
              "files": [
                "collaborative-session.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T083",
        "name": "Design Json Payload Studio",
        "task": {
          "id": "P4.T083",
          "feature_id": "F035",
          "title": "Design Json Payload Studio",
          "description": "Design task for Json Payload Studio",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f035-design.md",
                "docs/api/f035-openapi.yaml",
                "docs/schemas/f035-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "JSON lint and schema errors highlighted with line/col.",
              "script": "test_p4.t083.sh"
            },
            {
              "type": "automated",
              "description": "Template list with fuzzy search and quick preview.",
              "script": "test_p4.t083.sh"
            },
            {
              "type": "automated",
              "description": "Enqueue supports count, priority, delay/run\u2011at, and optional cron.",
              "script": "test_p4.t083.sh"
            },
            {
              "type": "manual",
              "description": "Diff/peek integration shows exactly what was sent.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement editor widget + linting",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/json-payload-studio.md",
              "excerpt": "An in\u2011TUI JSON editor to author, validate, and enqueue job payloads. Includes templates, snippets, schema validation, scheduling (run\u2011at/cron), and pretty diff/peek integration for rapid iteration.\n\n>",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Editor: textinput/viewport hybrid with syntax highlight (lightweight), bracket matching, and JSON linting.",
              "Templates: load from `config/templates/*.json` or inline; snippet expansion (e.g., `now()`, `uuid()`).",
              "Validation: optional JSON Schema (draft 7) validation per queue/template; show errors inline.",
              "Enqueue: `e` submits to selected queue; `E` opens count + schedule options (run\u2011at ISO8601, optional cron spec).",
              "Safety: size/field caps; strip secrets from UI logs; confirm in non\u2011test envs.",
              "Integration: peek last enqueued sample; diff between current editor buffer and last run."
            ],
            "user_stories": [
              "I can open a template, edit, validate, and enqueue with one keystroke.",
              "I can schedule a safe backfill at off\u2011peak with guardrails.",
              "I can see a redacted preview and confirm before enqueuing to prod."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T084",
        "name": "Implement Json Payload Studio",
        "task": {
          "id": "P4.T084",
          "feature_id": "F035",
          "title": "Implement Json Payload Studio",
          "description": "Implement task for Json Payload Studio",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "JSON lint and schema errors highlighted with line/col.",
                "Template list with fuzzy search and quick preview.",
                "Enqueue supports count, priority, delay/run\u2011at, and optional cron."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/json-payload-studio/",
                "internal/json-payload-studio/*_test.go",
                "docs/api/json-payload-studio.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [
              "redis_schema"
            ],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "JSON lint and schema errors highlighted with line/col.",
              "script": "test_p4.t084.sh"
            },
            {
              "type": "automated",
              "description": "Template list with fuzzy search and quick preview.",
              "script": "test_p4.t084.sh"
            },
            {
              "type": "automated",
              "description": "Enqueue supports count, priority, delay/run\u2011at, and optional cron.",
              "script": "test_p4.t084.sh"
            },
            {
              "type": "manual",
              "description": "Diff/peek integration shows exactly what was sent.",
              "script": null
            },
            {
              "type": "manual",
              "description": "Implement editor widget + linting",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/json-payload-studio.md",
              "excerpt": "An in\u2011TUI JSON editor to author, validate, and enqueue job payloads. Includes templates, snippets, schema validation, scheduling (run\u2011at/cron), and pretty diff/peek integration for rapid iteration.\n\n>",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Implement editor widget + linting",
              "Template loader + snippets",
              "Schema validation + error UI",
              "Enqueue + schedule flow",
              "Diff/peek integration",
              "Docs + screenshots"
            ],
            "technical_approach": [
              "Editor: textinput/viewport hybrid with syntax highlight (lightweight), bracket matching, and JSON linting.",
              "Templates: load from `config/templates/*.json` or inline; snippet expansion (e.g., `now()`, `uuid()`).",
              "Validation: optional JSON Schema (draft 7) validation per queue/template; show errors inline.",
              "Enqueue: `e` submits to selected queue; `E` opens count + schedule options (run\u2011at ISO8601, optional cron spec).",
              "Safety: size/field caps; strip secrets from UI logs; confirm in non\u2011test envs.",
              "Integration: peek last enqueued sample; diff between current editor buffer and last run."
            ],
            "code_structure": {
              "main_package": "internal/json-payload-studio",
              "files": [
                "json-payload-studio.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T085",
        "name": "Design Worker Fleet Controls",
        "task": {
          "id": "P3.T085",
          "feature_id": "F036",
          "title": "Design Worker Fleet Controls",
          "description": "Design task for Worker Fleet Controls",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f036-design.md",
                "docs/api/f036-openapi.yaml",
                "docs/schemas/f036-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Admin API supplies workers list and control endpoints (pause/resume/drain).",
              "script": "test_p3.t085.sh"
            },
            {
              "type": "automated",
              "description": "TUI lists workers, supports multi\u2011select, and shows action progress.",
              "script": "test_p3.t085.sh"
            },
            {
              "type": "automated",
              "description": "Safety checks prevent accidental global stoppage.",
              "script": "test_p3.t085.sh"
            },
            {
              "type": "manual",
              "description": "Admin: workers list + control endpoints",
              "script": null
            },
            {
              "type": "manual",
              "description": "Worker: honor pause/drain signals; expose state in heartbeat",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/worker-fleet-controls.md",
              "excerpt": "Operate the worker fleet from the TUI: pause/resume/drain nodes, rolling restarts, and live worker summaries (ID, last heartbeat, active job). Provide precise controls with confirmations and safeguard",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Registry: persist worker IDs, heartbeats, and current job (keyed by worker). Already partially present\u2014extend admin for list/read.",
              "Commands:",
              "Pause: worker stops pulling new jobs; finishes current if any.",
              "Resume: worker resumes pulls.",
              "Drain: like pause, then exit after current job; pool\u2011wide drain option.",
              "Rolling restart: N\u2011at\u2011a\u2011time drain+exit with max unavailable.",
              "TUI: Workers tab lists workers with statuses; select one/many; action bar with confirmations showing impact.",
              "Safety: prevent draining all by mistake; require typed confirmation in prod; show ETA estimates from running jobs.",
              "Audit: log who/when/what with success/failure; expose via Admin API."
            ],
            "user_stories": [
              "I can see a list of workers with last heartbeat and active job.",
              "I can pause or drain a worker safely with a confirmation and see state transition.",
              "I can perform a rolling restart with a concurrency cap."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P3.T086",
        "name": "Implement Worker Fleet Controls",
        "task": {
          "id": "P3.T086",
          "feature_id": "F036",
          "title": "Implement Worker Fleet Controls",
          "description": "Implement task for Worker Fleet Controls",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Admin API supplies workers list and control endpoints (pause/resume/drain).",
                "TUI lists workers, supports multi\u2011select, and shows action progress.",
                "Safety checks prevent accidental global stoppage."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/worker-fleet-controls/",
                "internal/worker-fleet-controls/*_test.go",
                "docs/api/worker-fleet-controls.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Admin API supplies workers list and control endpoints (pause/resume/drain).",
              "script": "test_p3.t086.sh"
            },
            {
              "type": "automated",
              "description": "TUI lists workers, supports multi\u2011select, and shows action progress.",
              "script": "test_p3.t086.sh"
            },
            {
              "type": "automated",
              "description": "Safety checks prevent accidental global stoppage.",
              "script": "test_p3.t086.sh"
            },
            {
              "type": "manual",
              "description": "Admin: workers list + control endpoints",
              "script": null
            },
            {
              "type": "manual",
              "description": "Worker: honor pause/drain signals; expose state in heartbeat",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/worker-fleet-controls.md",
              "excerpt": "Operate the worker fleet from the TUI: pause/resume/drain nodes, rolling restarts, and live worker summaries (ID, last heartbeat, active job). Provide precise controls with confirmations and safeguard",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Admin: workers list + control endpoints",
              "Worker: honor pause/drain signals; expose state in heartbeat",
              "TUI: list, select, actions, confirmations",
              "Audit logs + docs"
            ],
            "technical_approach": [
              "Registry: persist worker IDs, heartbeats, and current job (keyed by worker). Already partially present\u2014extend admin for list/read.",
              "Commands:",
              "Pause: worker stops pulling new jobs; finishes current if any.",
              "Resume: worker resumes pulls.",
              "Drain: like pause, then exit after current job; pool\u2011wide drain option.",
              "Rolling restart: N\u2011at\u2011a\u2011time drain+exit with max unavailable.",
              "TUI: Workers tab lists workers with statuses; select one/many; action bar with confirmations showing impact.",
              "Safety: prevent draining all by mistake; require typed confirmation in prod; show ETA estimates from running jobs.",
              "Audit: log who/when/what with success/failure; expose via Admin API."
            ],
            "code_structure": {
              "main_package": "internal/worker-fleet-controls",
              "files": [
                "worker-fleet-controls.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T087",
        "name": "Design Right Click Context Menus",
        "task": {
          "id": "P4.T087",
          "feature_id": "F037",
          "title": "Design Right Click Context Menus",
          "description": "Design task for Right Click Context Menus",
          "boundaries": {
            "expected_complexity": {
              "value": "1 design doc, ~800-1200 lines",
              "breakdown": "Architecture (400), API spec (300), Data model (200), Diagrams (300)"
            },
            "definition_of_done": {
              "criteria": [
                "Architecture documented with Mermaid diagrams",
                "API endpoints specified in OpenAPI 3.0 format",
                "Data models defined with JSON Schema",
                "Integration points identified and documented",
                "Security threat model completed",
                "Performance requirements specified",
                "Testing strategy defined"
              ],
              "stop_when": "Design approved by architect; do NOT start implementation"
            },
            "scope": {
              "includes": [
                "docs/design/f037-design.md",
                "docs/api/f037-openapi.yaml",
                "docs/schemas/f037-schema.json"
              ],
              "excludes": [
                "implementation code",
                "tests",
                "deployment configs"
              ],
              "restrictions": "Must follow company design template"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "cp1",
                "at_percent": 25,
                "description": "Architecture draft complete"
              },
              {
                "id": "cp2",
                "at_percent": 50,
                "description": "API specification complete"
              },
              {
                "id": "cp3",
                "at_percent": 75,
                "description": "Data models and diagrams complete"
              },
              {
                "id": "cp4",
                "at_percent": 100,
                "description": "Review and approval"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 512,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 1024,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "documentation",
              "architecture",
              "api_design"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 4,
            "mostLikely": 8,
            "pessimistic": 16
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Precise hitboxes with `bubblezone` on rows/tabs.",
              "script": "test_p4.t087.sh"
            },
            {
              "type": "automated",
              "description": "Context menu overlays with keyboard + mouse interaction.",
              "script": "test_p4.t087.sh"
            },
            {
              "type": "automated",
              "description": "Destructive actions gated with explicit confirmation.",
              "script": "test_p4.t087.sh"
            },
            {
              "type": "manual",
              "description": "Integrate `bubblezone` and register zones",
              "script": null
            },
            {
              "type": "manual",
              "description": "Build menu overlay component",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/right-click-context-menus.md",
              "excerpt": "Add contextual menus on right\u2011click (and `m`) across the TUI to expose actions where users are looking: peek, requeue, purge (confirmed), copy payload/key, open trace, export sample. Menus appear adja",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "design_sections": [
              "Executive Summary",
              "System Architecture",
              "API Specification",
              "Data Models",
              "Security Model",
              "Performance Requirements",
              "Testing Strategy",
              "Deployment Plan"
            ],
            "deliverables": [
              "Architecture document (Markdown + Mermaid)",
              "OpenAPI 3.0 specification",
              "JSON Schema definitions",
              "Security threat model",
              "Performance benchmarks"
            ],
            "technical_approach": [
              "Hitboxes: integrate `bubblezone` to register zones for tabs, table rows, charts, and info regions.",
              "Menu widget: lightweight overlay with items, accelerators, and disabled states; auto\u2011positions within viewport.",
              "Action registry: map context (e.g., queue row, DLQ item) to available actions with capability checks.",
              "Safety: destructive items require confirm modal; show exact scope (e.g., \u201cPurge DLQ dead_letter (123 items)\u201d).",
              "Keyboard parity: `m` opens context menu for the focused item; arrow/enter to select.",
              "Extensibility: plug new actions via registry to avoid scattering logic."
            ],
            "user_stories": [
              "I can right\u2011click a queue row and choose Peek or Enqueue.",
              "I can right\u2011click DLQ items and Requeue/Purge with confirmation."
            ]
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      },
      {
        "id": "P4.T088",
        "name": "Implement Right Click Context Menus",
        "task": {
          "id": "P4.T088",
          "feature_id": "F037",
          "title": "Implement Right Click Context Menus",
          "description": "Implement task for Right Click Context Menus",
          "boundaries": {
            "expected_complexity": {
              "value": "~ LoC",
              "breakdown": "Core logic (60%), Tests (25%), Integration (15%)"
            },
            "definition_of_done": {
              "criteria": [
                "All functions implemented per specification",
                "Unit tests passing with 80% coverage",
                "Integration tests passing",
                "Code reviewed and approved",
                "Documentation updated",
                "No linting errors",
                "Performance benchmarks met",
                "Precise hitboxes with `bubblezone` on rows/tabs.",
                "Context menu overlays with keyboard + mouse interaction.",
                "Destructive actions gated with explicit confirmation."
              ],
              "stop_when": "Core functionality complete; do NOT add extra features"
            },
            "scope": {
              "includes": [
                "internal/right-click-context-menus/",
                "internal/right-click-context-menus/*_test.go",
                "docs/api/right-click-context-menus.md"
              ],
              "excludes": [
                "UI unless specified",
                "deployment configs"
              ],
              "restrictions": "Follow existing code patterns and style guide"
            }
          },
          "execution_guidance": {
            "logging": {
              "format": "JSON Lines (JSONL)",
              "required_fields": [
                "timestamp",
                "task_id",
                "step",
                "status",
                "message"
              ],
              "optional_fields": [
                "percent",
                "data",
                "checkpoint"
              ],
              "status_values": [
                "start",
                "progress",
                "done",
                "error",
                "checkpoint"
              ]
            },
            "checkpoints": [
              {
                "id": "setup",
                "at_percent": 10,
                "description": "Module structure created"
              },
              {
                "id": "core",
                "at_percent": 40,
                "description": "Core logic implemented"
              },
              {
                "id": "integration",
                "at_percent": 60,
                "description": "Integration complete"
              },
              {
                "id": "tests",
                "at_percent": 80,
                "description": "Tests passing"
              },
              {
                "id": "docs",
                "at_percent": 100,
                "description": "Documentation complete"
              }
            ],
            "monitoring": {
              "metrics_to_track": [],
              "alerts": []
            }
          },
          "resource_requirements": {
            "estimated": {
              "cpu_cores": 1,
              "memory_mb": 1024,
              "disk_io_mbps": 10
            },
            "peak": {
              "cpu_cores": 2,
              "memory_mb": 2048,
              "disk_io_mbps": 50,
              "during": "compilation or testing"
            },
            "worker_capabilities_required": [
              "golang",
              "backend",
              "redis"
            ]
          },
          "scheduling_hints": {
            "priority": "medium",
            "preemptible": true,
            "retry_on_failure": true,
            "max_retries": 3,
            "checkpoint_capable": true
          },
          "duration": {
            "optimistic": 8,
            "mostLikely": 16,
            "pessimistic": 24
          },
          "shared_resources": {
            "exclusive_locks": [],
            "shared_limited": [
              {
                "resource": "test_redis",
                "quantity": 1
              }
            ],
            "creates": [],
            "modifies": []
          },
          "acceptance_checks": [
            {
              "type": "automated",
              "description": "Precise hitboxes with `bubblezone` on rows/tabs.",
              "script": "test_p4.t088.sh"
            },
            {
              "type": "automated",
              "description": "Context menu overlays with keyboard + mouse interaction.",
              "script": "test_p4.t088.sh"
            },
            {
              "type": "automated",
              "description": "Destructive actions gated with explicit confirmation.",
              "script": "test_p4.t088.sh"
            },
            {
              "type": "manual",
              "description": "Integrate `bubblezone` and register zones",
              "script": null
            },
            {
              "type": "manual",
              "description": "Build menu overlay component",
              "script": null
            }
          ],
          "evidence": [
            {
              "type": "plan",
              "source": "docs/ideas/right-click-context-menus.md",
              "excerpt": "Add contextual menus on right\u2011click (and `m`) across the TUI to expose actions where users are looking: peek, requeue, purge (confirmed), copy payload/key, open trace, export sample. Menus appear adja",
              "confidence": 1.0,
              "rationale": "Primary feature specification"
            }
          ],
          "implementation_spec": {
            "implementation_checklist": [
              "Integrate `bubblezone` and register zones",
              "Build menu overlay component",
              "Implement action registry + confirm hooks",
              "Wire menus in Queues + DLQ",
              "Update help/docs"
            ],
            "technical_approach": [
              "Hitboxes: integrate `bubblezone` to register zones for tabs, table rows, charts, and info regions.",
              "Menu widget: lightweight overlay with items, accelerators, and disabled states; auto\u2011positions within viewport.",
              "Action registry: map context (e.g., queue row, DLQ item) to available actions with capability checks.",
              "Safety: destructive items require confirm modal; show exact scope (e.g., \u201cPurge DLQ dead_letter (123 items)\u201d).",
              "Keyboard parity: `m` opens context menu for the focused item; arrow/enter to select.",
              "Extensibility: plug new actions via registry to avoid scattering logic."
            ],
            "code_structure": {
              "main_package": "internal/right-click-context-menus",
              "files": [
                "right-click-context-menus.go - Main implementation",
                "types.go - Data structures",
                "handlers.go - Request handlers",
                "errors.go - Custom errors",
                "config.go - Configuration"
              ]
            }
          }
        },
        "state": "PENDING",
        "attempts": 0,
        "lastError": null
      }
    ],
    "edges": [
      {
        "from": "P1.T001",
        "to": "P1.T002",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T002",
        "to": "P1.T003",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T003",
        "to": "P1.T004",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T005",
        "to": "P2.T006",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T006",
        "to": "P2.T007",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T008",
        "to": "P2.T009",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T009",
        "to": "P2.T010",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T011",
        "to": "P1.T012",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T012",
        "to": "P1.T013",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T013",
        "to": "P1.T014",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T015",
        "to": "P4.T016",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T017",
        "to": "P4.T018",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T019",
        "to": "P1.T020",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T020",
        "to": "P1.T021",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T021",
        "to": "P1.T022",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T023",
        "to": "P1.T024",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T024",
        "to": "P1.T025",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T025",
        "to": "P1.T026",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T027",
        "to": "P4.T028",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T029",
        "to": "P4.T030",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T031",
        "to": "P4.T032",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T033",
        "to": "P4.T034",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T035",
        "to": "P3.T036",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T037",
        "to": "P2.T038",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T038",
        "to": "P2.T039",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T040",
        "to": "P3.T041",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T042",
        "to": "P3.T043",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T044",
        "to": "P4.T045",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T046",
        "to": "P3.T047",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T048",
        "to": "P4.T049",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T050",
        "to": "P2.T051",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T051",
        "to": "P2.T052",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T053",
        "to": "P3.T054",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T055",
        "to": "P4.T056",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T057",
        "to": "P2.T058",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T058",
        "to": "P2.T059",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T060",
        "to": "P2.T061",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P2.T061",
        "to": "P2.T062",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T063",
        "to": "P4.T064",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T065",
        "to": "P4.T066",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T067",
        "to": "P4.T068",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T069",
        "to": "P3.T070",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T071",
        "to": "P3.T072",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T073",
        "to": "P4.T074",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T075",
        "to": "P4.T076",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T077",
        "to": "P3.T078",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T079",
        "to": "P4.T080",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T081",
        "to": "P4.T082",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T083",
        "to": "P4.T084",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T085",
        "to": "P3.T086",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T087",
        "to": "P4.T088",
        "type": "sequential",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P4.T049",
        "to": "P4.T031",
        "type": "technical",
        "weight": 0.9,
        "isHard": true
      },
      {
        "from": "P4.T049",
        "to": "P4.T075",
        "type": "technical",
        "weight": 0.9,
        "isHard": false
      },
      {
        "from": "P1.T004",
        "to": "P1.T014",
        "type": "mutual_exclusion",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T004",
        "to": "P1.T022",
        "type": "mutual_exclusion",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T004",
        "to": "P1.T026",
        "type": "mutual_exclusion",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T014",
        "to": "P1.T022",
        "type": "mutual_exclusion",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T014",
        "to": "P1.T026",
        "type": "mutual_exclusion",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P1.T022",
        "to": "P1.T026",
        "type": "mutual_exclusion",
        "weight": 1.0,
        "isHard": true
      },
      {
        "from": "P3.T047",
        "to": "P4.T084",
        "type": "mutual_exclusion",
        "weight": 1.0,
        "isHard": true
      }
    ]
  },
  "policies": {
    "concurrency_max": 10,
    "fairness": "weighted_priority",
    "circuit_breakers": {
      "enabled": true,
      "patterns": [
        {
          "name": "missing_dependency",
          "regex": "Cannot resolve|not found|missing",
          "threshold": 2,
          "action": "inject_install_task"
        },
        {
          "name": "rate_limit",
          "regex": "429|rate limit|too many",
          "threshold": 3,
          "action": "add_backoff"
        },
        {
          "name": "resource_exhausted",
          "regex": "OOM|timeout|resource exhausted",
          "threshold": 1,
          "action": "increase_resources"
        }
      ]
    },
    "lock_policy": "try-lock-wait-die",
    "update_mode": "hot",
    "checkpoint_interval_percent": 25,
    "retry_policy": {
      "max_attempts": 3,
      "backoff": "exponential",
      "initial_delay_ms": 1000,
      "max_delay_ms": 60000
    }
  },
  "resources": {
    "locks": [
      "deployment_slot",
      "redis_schema"
    ],
    "quotas": {
      "test_redis": 2,
      "ci_runners": 1
    },
    "worker_pool": {
      "min": 2,
      "max": 8,
      "scale_up_threshold": 0.8,
      "scale_down_threshold": 0.3
    }
  },
  "monitoring": {
    "metrics_port": 9090,
    "log_level": "info",
    "trace_sampling_rate": 0.1,
    "health_check_interval_seconds": 30
  }
}